<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Êñá‰ª∂Á≥ªÁªüÂ™í‰ΩìÊµèËßàÂô®</title>
    <link rel="manifest" href="{{ url_for('static', filename='manifest.json') }}">
    <style>
        :root { --background-color: #242424; --text-color: #FFFFFF; --button-color: #3B3B3B; --button-hover-color: #888888; --card-background-color: #494141; --card-border-color: #333333; --nav-text-color: #AAAAAA; --placeholder-text-color: #CCCCCC; --font-family: 'Microsoft YaHei', 'Segoe UI', 'WenQuanYi Micro Hei', sans-serif; --label-start-r: 95; --label-start-g: 15; --label-start-b: 64; --label-end-r: 220; --label-end-g: 47; --label-end-b: 2; }
        body { background-color: var(--background-color); color: var(--text-color); font-family: var(--font-family); margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        .header-container, .nav-frame { padding: 10px 20px; flex-shrink: 0; }
        .header { display: flex; justify-content: space-between; align-items: center; }
        .header-controls { display: flex; gap: 10px; align-items: center; }
        .header-right-controls { display: flex; gap: 10px; align-items: center; position: relative; }
        .button, input[type="text"], select { background-color: var(--button-color); color: var(--text-color); border: 1px solid var(--card-border-color); border-radius: 6px; padding: 8px 12px; font-size: 14px; cursor: pointer; transition: background-color 0.2s; }
        .button:hover, select:hover { background-color: var(--button-hover-color); }
        input[type="text"] { width: 300px; }
        input[type="text"]::placeholder { color: var(--placeholder-text-color); }
        select { -webkit-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23%23AAAAAA%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22/%3E%3C/svg%3E'); background-repeat: no-repeat; background-position: right 12px center; background-size: 10px auto; padding-right: 30px; }
        .nav-frame { color: var(--nav-text-color); font-size: 12px; padding-top: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .main-content { flex-grow: 1; overflow-y: auto; padding: 0 15px 15px 15px; }
        #media-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(230px, 1fr)); gap: 12px; }
        #media-container.jav-mode, #media-container.anime-mode { grid-template-columns: repeat(auto-fill, minmax(380px, 1fr)); }
        .card { background-color: var(--card-background-color); border: 1px solid var(--card-border-color); border-radius: 8px; overflow: hidden; display: flex; flex-direction: column; }
        .card-image-wrapper { width: 100%; background-color: #1E1E1E; display: flex; justify-content: center; align-items: center; color: var(--nav-text-color); font-size: 16px; text-align: center; padding: 10px; box-sizing: border-box; cursor: pointer; }
        .manga-mode .card-image-wrapper, .novel-mode .card-image-wrapper, .other-mode .card-image-wrapper, .anime-mode .card-image-wrapper { aspect-ratio: 2 / 3; }
        .music-mode .card-image-wrapper { aspect-ratio: 1 / 1; }
        .jav-mode .card-image-wrapper { aspect-ratio: 800 / 538; }
        .card-image-wrapper img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .card-info { padding: 8px 12px; flex-grow: 1; display: flex; flex-direction: column; gap: 8px; cursor: default; }
        .card-filename { font-size: 14px; word-break: break-all; }
        .card-tags { display: flex; flex-wrap: wrap; gap: 6px; min-height: 24px; }
        .card-tag { font-size: 12px; padding: 2px 6px; border-radius: 5px; color: white; cursor: pointer; transition: transform 0.1s; }
        .card-tag:hover { transform: scale(1.05); }
        .tag-edit-unit { display: flex; align-items: center; background-color: #555; border-radius: 5px; }
        .del-tag-btn { font-size: 12px; padding: 1px 5px; margin-left:2px; background-color: #C00000; color: white; border-radius: 0 5px 5px 0; cursor: pointer; }
        .del-tag-btn:hover { background-color: red; }
        .add-tag-btn { font-size: 14px; width: 22px; height: 22px; padding: 0; line-height:22px; text-align:center; background-color: #3B3B3B; cursor:pointer; border-radius:5px; }
        .add-tag-btn:hover{ background-color: #888; }
        .open-folder-btn { position: fixed; bottom: 20px; right: 20px; z-index: 50; }
        #loading-indicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; display: none; z-index: 2000; }
        #maintenance-menu { display: none; position: absolute; top: 100%; right: 0; background-color: var(--card-background-color); border: 1px solid var(--card-border-color); border-radius: 6px; z-index: 100; padding: 5px; min-width: 120px; }
        #maintenance-menu .button { width: 100%; text-align: left; margin-bottom: 5px; }
        #maintenance-menu .button:last-child { margin-bottom: 0; }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .overlay.active { display: flex; }
        .overlay .close-btn { position: absolute; top: 26px; left: 80px; font-size: 34px; color: white; cursor: pointer; z-index: 1010; text-shadow: 0 0 5px black; line-height: 1;}
        .overlay .close-btn:hover { color: #ff4d4d; }
        #image-viewer { flex-direction: row; padding: 20px; box-sizing: border-box; }
        #image-viewer .image-container { flex-grow: 1; display: flex; justify-content: center; align-items: center; height: 100%; padding: 0; }
        #image-viewer .image-container img { max-width: 100%; max-height: 100%; object-fit: contain; opacity: 0; transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #image-viewer .progress-bar { width: 70px; height: 100%; display: flex; flex-direction: column; justify-content: center; padding: 0; box-sizing: border-box; gap: 1px; cursor: pointer; }
        .progress-segment-wrapper { display: flex; align-items: center; justify-content: flex-end; flex-grow: 1; }
        .progress-label { width: 30px; font-size: 10px; color: #cccccc; text-align: right; padding-right: 5px; flex-shrink: 0; }
        #image-viewer .progress-segment { flex-grow: 1; max-width: 15px; align-self: stretch; background-color: #555; border-radius: 2px; transition: background-color 0.2s; }
        #image-viewer .progress-segment.active { background-color: #3B8ED0; }
        #video-player video { max-width: 95vw; max-height: 95vh; outline: none; }
        #fullscreen-btn { position: absolute; top: 25px; left: 30px; font-size: 28px; color: white; cursor: pointer; z-index: 1010; text-shadow: 0 0 5px black; }
        #fullscreen-btn:hover { color: #87cefa; }
        .add-tag-btn, .auto-import-btn { font-size: 14px; width: 22px; height: 22px; padding: 0; line-height:22px; text-align:center; background-color: #3B3B3B; cursor:pointer; border-radius:5px; display: inline-block; margin-left: 4px; vertical-align: middle; }
        .add-tag-btn:hover, .auto-import-btn:hover { background-color: #888; }
        .auto-import-btn[disabled] { cursor: not-allowed; background-color: #555; }
        /* --- START: EPUB Viewer Style Overhaul --- */
        #epub-viewer {
            /* Use Flexbox for robust vertical layout */
            flex-direction: column;
            justify-content: space-between; /* Pushes top/bottom bars to edges */
            padding: 20px;
            box-sizing: border-box;
            height: 100vh; 
            box-sizing: border-box;
        }
        #epub-top-bar, #epub-bottom-bar {
            flex-shrink: 0; /* Prevent bars from shrinking */
            display: flex;
            align-items: center;
            width: 100%;
            padding: 10px 0;
        }
        #epub-top-bar {
            justify-content: flex-start; /* Align close button to the left */
        }
        #epub-bottom-bar {
            justify-content: center; /* Center navigation buttons */
            gap: 15px; /* Space between buttons */
        }
        /* Override the default close button position for this specific viewer */
        #epub-viewer .close-btn {
            position: static; /* Remove absolute positioning */
            font-size: 28px;
            line-height: 1;
        }
        #epub-area-wrapper {
            flex-grow: 1; 
            width: 100%;
            max-width: 900px; 
            margin: 0 auto;
            overflow: hidden;
            display: flex;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #epub-area {
            width: 100%;
            height: 100%;
            background-color: white;
        }
        #prev-page-btn, #next-page-btn {
            font-size: 14px;
            padding: 8px 20px;
        }

        /* --- NEW: Album View and Music Player Styles --- */
        #album-view {
            flex-direction: row;
            align-items: flex-start;
            padding: 80px 40px 40px 40px;
            gap: 40px;
            background: linear-gradient(rgba(0,0,0,0.5), #121212 40%);
        }
        #album-view .album-info {
            flex-shrink: 0;
            width: 300px;
            text-align: center;
        }
        #album-view .album-art {
            width: 100%;
            aspect-ratio: 1 / 1;
            object-fit: cover;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            background-color: #333;
        }
        #album-view .album-title {
            margin-top: 20px;
            font-size: 24px;
            font-weight: bold;
        }
        #album-view .track-list-container {
            flex-grow: 1;
            height: calc(100vh - 220px); /* ÂáèÂéªpaddingÂíåÊéßÂà∂Êù°ÁöÑÈ´òÂ∫¶ */
            overflow-y: auto;
        }
        #album-view .track-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #album-view .track-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #album-view .track-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        #album-view .track-item.playing {
            background-color: rgba(40, 150, 255, 0.2);
            color: #70b8ff;
        }
        .track-number {
            font-size: 16px;
            color: #aaa;
            width: 25px;
            text-align: right;
        }
        .track-title {
            font-size: 16px;
        }

        #music-player-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 90px;
            background-color: #181818;
            border-top: 1px solid #282828;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 10px 0;
            box-sizing: border-box;
            z-index: 1020; /* Á°Æ‰øùÂú®album-viewÊµÆÂ±Ç‰πã‰∏ä */
        }
        .control-buttons {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .control-button {
            background-color: transparent;
            border: 1px solid #555;
            border-radius: 5px;
            color: #b3b3b3;
            cursor: pointer;
            padding: 8px 16px;
            min-width: 90px;
            text-align: center;
            font-size: 14px; /* Áªü‰∏ÄÂ≠ó‰ΩìÂ§ßÂ∞è */
            transition: color 0.2s, border-color 0.2s, background-color 0.2s;
        }
        .control-button:hover {
            color: #fff;
            border-color: #888;
        }
        .control-button.play-pause {
            font-size: 14px; /* Áªü‰∏ÄÂ≠ó‰ΩìÂ§ßÂ∞è */
            min-width: 100px;
        }
        .control-button.active {
            color: #1DB954; /* Spotify Green */
            border-color: #1DB954;
        }
        #current-audio-player {
            width: 80%;
            max-width: 700px;
            margin-top: 10px;
        }
        /* --- NEW: Anime View Styles --- */
        #anime-view {
            flex-direction: row;
            align-items: stretch;
            padding: 40px;
            gap: 20px;
            background: #181818;
            height: 100vh; /* Â∞ÜÂÆπÂô®È´òÂ∫¶ÈôêÂà∂‰∏∫Êï¥‰∏™ËßÜÂè£È´òÂ∫¶ */
            box-sizing: border-box; /* Á°Æ‰øù padding ‰∏ç‰ºöÂ¢ûÂä†È¢ùÂ§ñÁöÑÈ´òÂ∫¶ */
        }
        .anime-player-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        #anime-video-wrapper {
            flex-grow: 1;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            overflow: hidden;
        }
        #current-anime-video {
            width: 100%;
            height: 100%;
            outline: none;
        }
        #anime-controls-wrapper {
            flex-shrink: 0;
            padding-top: 15px;
            display: flex;
            gap: 10px;
        }
        .episode-list-container {
            flex-shrink: 0;
            width: 200px;
            background-color: #121212;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            max-height: calc(100% - 45px); /* ËÆæÁΩÆÊúÄÂ§ßÈ´òÂ∫¶ÔºåÂáèÂéªÊ†áÈ¢òÁöÑËøë‰ººÈ´òÂ∫¶ÂíåËæπË∑ù */
        }
        #anime-title-text {
            margin: 0 0 15px 0;
            padding-bottom: 15px;
            border-bottom: 1px solid #282828;
            font-size: 20px;
        }
        .episode-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            flex-grow: 1;
        }
        .episode-item {
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .episode-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .episode-item.playing {
            background-color: rgba(40, 150, 255, 0.2);
            color: #70b8ff;
            font-weight: bold;
        }

    </style>
</head>
<body>
    <div class="header-container">
        <div class="header">
            <div class="header-controls">
                <select id="mode-selector" class="button">
                    <option value="MANGA">MANGA</option>
                    <option value="JAV">JAV</option>
                    <option value="ANIME">ANIME</option>
                    <option value="MUSIC">MUSIC</option>
                    <option value="NOVEL">NOVEL</option>
                    <option value="OTHER">OTHER</option>
                </select>
                <input type="text" id="search-input" placeholder="ËæìÂÖ•ÂÖ≥ÈîÆËØçÊêúÁ¥¢...">
                <button id="search-btn" class="button">ÊêúÁ¥¢</button>
            </div>
            <div class="header-right-controls">
                <button id="stats-btn" class="button">ÁªüËÆ°</button>
                <div class="maintenance-container" style="position: relative;">
                    <button id="maintenance-btn" class="button">Áª¥Êä§</button>
                    <div id="maintenance-menu">
                        <button id="generate-covers-btn" class="button">ÁîüÊàêÂ∞ÅÈù¢</button>
                        <button id="edit-tags-btn" class="button">ÁºñËæëTag</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="nav-frame">
        <button id="back-btn" class="button" style="margin-right: 10px; display: none;">ËøîÂõû</button>
        <span id="current-path-label">Ê≠£Âú®Âä†ËΩΩ...</span>
    </div>
    <div class="main-content">
        <div id="media-container" class="manga-mode"></div>
    </div>
    <button id="open-folder-btn" class="button open-folder-btn">ÊâìÂºÄÊâÄÂú®ÁõÆÂΩï</button>
    <div id="loading-indicator">Ê≠£Âú®Âä†ËΩΩ...</div>

    <div id="image-viewer" class="overlay">
        <span id="fullscreen-btn">‚õ∂</span>
        <span class="close-btn">&times;</span>
        <div class="image-container">
            <img id="current-image" src="" alt="viewer image">
        </div>
        <div id="progress-bar-container" class="progress-bar"></div>
    </div>
    <div id="epub-viewer" class="overlay">
        <div id="epub-top-bar">
            <span class="close-btn">&times;</span>
        </div>

        <div id="epub-area-wrapper">
            <div id="epub-area"></div>
        </div>

        <div id="epub-bottom-bar">
            <button id="prev-page-btn" class="button">&lt; ‰∏ä‰∏ÄÈ°µ</button>
            <button id="next-page-btn" class="button">‰∏ã‰∏ÄÈ°µ &gt;</button>
        </div>
    </div>
    <div id="video-player" class="overlay">
        <span class="close-btn">&times;</span>
        <video id="current-video" controls autoplay></video>
    </div>
    <div id="album-view" class="overlay">
        <span class="close-btn">&times;</span>
        <div class="album-info">
            <img id="album-art-img" src="" class="album-art">
            <h2 id="album-title-text" class="album-title"></h2>
        </div>
        <div class="track-list-container">
            <ol id="track-list-ui" class="track-list"></ol>
        </div>
        <div id="music-player-controls">
            <div class="control-buttons">
                <button id="shuffle-btn" class="control-button" title="ÈöèÊú∫Êí≠Êîæ">ÈöèÊú∫Â∑≤ÂÖ≥</button>
                <button id="prev-btn" class="control-button">‰∏ä‰∏ÄÈ¶ñ</button>
                <button id="play-pause-btn" class="control-button play-pause">Êí≠Êîæ</button>
                <button id="next-btn" class="control-button">‰∏ã‰∏ÄÈ¶ñ</button>
                <button id="repeat-btn" class="control-button" title="Âæ™ÁéØÊ®°Âºè">È°∫Â∫èÊí≠Êîæ</button>
            </div>
            <audio id="current-audio-player" controls></audio>
        </div>
    </div>
    <div id="anime-view" class="overlay">
        <span class="close-btn">&times;</span>
        <div class="anime-player-container">
            <div id="anime-video-wrapper">
                <video id="current-anime-video" controls autoplay>
                    <track kind="subtitles" srclang="zh" label="Default Subtitles">
                </video>
            </div>
            <div id="anime-controls-wrapper">
                 <button id="toggle-subtitle-btn" class="button">ÈöêËóèÂ≠óÂπï</button>
                 <select id="subtitle-selector-btn" class="button" style="display: none;"></select>
            </div>
        </div>
        <div class="episode-list-container">
            <h2 id="anime-title-text"></h2>
            <ol id="episode-list-ui" class="episode-list"></ol>
        </div>
    </div>
    <template id="card-template">
        <div class="card">
            <div class="card-image-wrapper">
                <img>
                <span class="placeholder-text"></span>
            </div>
            <div class="card-info">
                <div class="card-filename"></div>
                <div class="card-tags"></div>
            </div>
        </div>
    </template>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- ÂÖÉÁ¥†ÈÄâÊã©Âô® ---
        const modeSelector = document.getElementById('mode-selector');
        const searchInput = document.getElementById('search-input');
        const searchBtn = document.getElementById('search-btn');
        const pathLabel = document.getElementById('current-path-label');
        const mediaContainer = document.getElementById('media-container');
        const cardTemplate = document.getElementById('card-template');
        const openFolderBtn = document.getElementById('open-folder-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        const backBtn = document.getElementById('back-btn');
        // Viewers
        const imageViewer = document.getElementById('image-viewer');
        const imageContainer = imageViewer.querySelector('.image-container');
        const progressBarContainer = document.getElementById('progress-bar-container');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const currentImage = document.getElementById('current-image');
        const imageViewerCloseBtn = imageViewer.querySelector('.close-btn');
        const videoPlayer = document.getElementById('video-player');
        const currentVideo = document.getElementById('current-video');
        const videoPlayerCloseBtn = videoPlayer.querySelector('.close-btn');
        const animeView = document.getElementById('anime-view');
        const animeViewCloseBtn = animeView.querySelector('.close-btn');
        const currentAnimeVideo = document.getElementById('current-anime-video');
        const animeTitleText = document.getElementById('anime-title-text');
        const episodeListUI = document.getElementById('episode-list-ui');
        const toggleSubtitleBtn = document.getElementById('toggle-subtitle-btn');
        // New Music Player / Album View
        const albumView = document.getElementById('album-view');
        const albumViewCloseBtn = albumView.querySelector('.close-btn');
        const albumArtImg = document.getElementById('album-art-img');
        const albumTitleText = document.getElementById('album-title-text');
        const trackListUI = document.getElementById('track-list-ui');
        const audioPlayer = document.getElementById('current-audio-player');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const nextBtn = document.getElementById('next-btn');
        const prevBtn = document.getElementById('prev-btn');
        const shuffleBtn = document.getElementById('shuffle-btn');
        const repeatBtn = document.getElementById('repeat-btn');
        // Maintenance
        const statsBtn = document.getElementById('stats-btn');
        const maintenanceBtn = document.getElementById('maintenance-btn');
        const maintenanceMenu = document.getElementById('maintenance-menu');
        const generateCoversBtn = document.getElementById('generate-covers-btn');
        const editTagsBtn = document.getElementById('edit-tags-btn');
        // ANIME Player
        const subtitleSelector = document.getElementById('subtitle-selector-btn');

        // --- Áä∂ÊÄÅÂØπË±° ---
        let state = {
            mode: 'MANGA',
            currentPath: '',
            pathStack: [],
            inSearchMode: false,
            isTagEditMode: false,
            renderingId: 0,
            tagsData: {},
            tempTagsData: {},
            gallery: { isOpen: false, baseMediaPath: '', itemKey: '', files: [], currentIndex: 0, isLoading: false }
        };
        let playerState = {
            currentTracklist: [],
            originalTracklist: [],
            baseMediaPath: '',
            currentIndex: -1,
            isPlaying: false,
            isShuffled: false,
            repeatMode: 'NONE', // NONE, ALL, ONE
        };
        let animePlayerState = {
            baseMediaPath: '',
            episodeTree: [], // Êñ∞Â¢ûÔºöÂ≠òÂÇ®Êï¥‰∏™ÂâßÈõÜÊ†ë
            currentPlayingPath: null, // Êñ∞Â¢ûÔºöÂ≠òÂÇ®ÂΩìÂâçÊí≠ÊîæËßÜÈ¢ëÁöÑË∑ØÂæÑ
            areSubtitlesVisible: true,
        };
        let activeImports = {};
        let viewerState = { rotationAngle: 0 };
        let wheelDebounceTimeout = null;
        let book = null;
        let rendition = null;
        let epubKeyListenerAbortController = null; 

        // --- Ê†∏ÂøÉÂäüËÉΩÂáΩÊï∞ ---
        function truncateFilename(name) {
            const nameNoExt = name.replace(/\.\w+$/, '');
            const match = nameNoExt.match(/\d+/); // Êü•ÊâæÁ¨¨‰∏Ä‰∏™Êï∞Â≠óÂ∫èÂàó

            if (!match) {
                // Â¶ÇÊûúÊ≤°ÊúâÊï∞Â≠óÔºåÊèê‰æõ‰∏Ä‰∏™Â§áÁî®Êà™Êñ≠ÊñπÊ°à
                return nameNoExt.length > 20 ? nameNoExt.substring(0, 17) + '...' : nameNoExt;
            }

            const numberStr = match[0];
            const index = match.index;
            
            // ËÆ°ÁÆóÊà™ÂèñËåÉÂõ¥ÔºöÊï∞Â≠óÂâçÂêéÂêÑ5‰∏™Â≠óÁ¨¶
            const start = Math.max(0, index - 5);
            const end = Math.min(nameNoExt.length, index + numberStr.length + 5);
            
            let result = nameNoExt.substring(start, end);
            
            // Â¶ÇÊûúÂâçÈù¢ÊàñÂêéÈù¢ÊúâÊõ¥Â§öÂ≠óÁ¨¶ÔºåÂàôÊ∑ªÂä†ÁúÅÁï•Âè∑
            if (start > 0) {
                result = '‚Ä¶' + result;
            }
            if (end < nameNoExt.length) {
                result = result + '‚Ä¶';
            }
            return result;
        }

        function findFirstVideo(nodes) {
            for (const node of nodes) {
                if (node.type === 'video') {
                    return node;
                }
                if (node.type === 'directory') {
                    const found = findFirstVideo(node.children);
                    if (found) {
                        return found;
                    }
                }
            }
            return null;
        }

        function applyImageViewerTransforms() {
            if (!state.gallery.isOpen) return;
            const { rotationAngle } = viewerState;
            let scale = 1;
            if (rotationAngle === 90 || rotationAngle === 270) {
                currentImage.style.maxWidth = 'none';
                currentImage.style.maxHeight = 'none';
                const img = currentImage;
                const container = imageContainer;
                if (img.naturalWidth > 0 && img.naturalHeight > 0) {
                    const scaleX = container.clientWidth / img.naturalHeight;
                    const scaleY = container.clientHeight / img.naturalWidth;
                    scale = Math.min(scaleX, scaleY);
                }
            } else {
                currentImage.style.maxWidth = '100%';
                currentImage.style.maxHeight = '100%';
            }
            currentImage.style.transformOrigin = `center center`;
            currentImage.style.transform = `rotate(${rotationAngle}deg) scale(${scale})`;
        }
        
        function showLoading(isLoading, clearContent = true) {
            loadingIndicator.style.display = isLoading ? 'block' : 'none';
            if (isLoading && clearContent) { mediaContainer.innerHTML = ''; }
        }

        async function fetchData(url, options = {}) {
            const clear = options.clearContentOnLoad !== false;
            showLoading(true, clear);
            try {
                const response = await fetch(url, options);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error("Fetch error:", error);
                mediaContainer.innerHTML = `<p style="padding:20px;">ËºâÂÖ•Â§±Êïó: ${error.message}</p>`;
                return null;
            } finally {
                showLoading(false, clear);
            }
        }
        
        async function browse(path = '') {
            state.renderingId++;
            if(state.isTagEditMode && !await confirmExitTagEditMode()) return;
            state.inSearchMode = false; searchInput.value = '';
            const url = path ? `/api/browse?mode=${state.mode}&path=${encodeURIComponent(path)}` : `/api/browse?mode=${state.mode}`;
            const data = await fetchData(url, { clearContentOnLoad: true });
            if (data && data.items) {
                state.currentPath = data.current_path;
                if (!state.pathStack.length || state.pathStack[state.pathStack.length - 1] !== data.current_path) { state.pathStack.push(data.current_path); }
                pathLabel.textContent = `Ê®°Âºè: ${state.mode} | ${state.currentPath}`;
                backBtn.style.display = state.pathStack.length > 1 ? 'inline-block' : 'none';
                mediaContainer.innerHTML = '';
                renderCardsStaggered(data.items, 0, state.renderingId);
            }
        }
        
        async function search(query, type = 'keyword') {
            if (!query) return;
            state.renderingId++;
            if(state.isTagEditMode && !await confirmExitTagEditMode()) return;
            state.inSearchMode = true;
            const url = `/api/search?mode=${state.mode}&q=${encodeURIComponent(query)}&type=${encodeURIComponent(type)}`;
            const data = await fetchData(url, { clearContentOnLoad: true });
            if (data && data.items) {
                const searchLabel = type === 'tag' ? `Ê®ôÁ±§ÊêúÁ¥¢: "${query}"` : `ÈóúÈçµË©ûÊêúÁ¥¢: "${query}"`;
                pathLabel.textContent = searchLabel;
                backBtn.style.display = 'inline-block';
                mediaContainer.innerHTML = '';
                renderCardsStaggered(data.items, 0, state.renderingId);
            }
        }

        async function recordView(itemKey, pageIndex = null) {
            if (state.isTagEditMode) return;
            try {
                fetch('/api/record_view', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ item_key: itemKey, page_index: pageIndex }),
                });
            } catch (error) {
                console.error('Failed to record view:', error);
            }
        }
        
        // --- Âç°ÁâáÊ∏≤ÊüìÂíå Tag UI ---
        function renderCardsStaggered(items, index = 0, currentRenderingId) {
            if (currentRenderingId !== state.renderingId || index >= items.length) return;
            const item = items[index];
            const cardClone = cardTemplate.content.cloneNode(true);
            const cardEl = cardClone.querySelector('.card');
            cardEl.dataset.path = item.full_path;
            cardEl.dataset.mediaPath = item.media_path;
            cardEl.dataset.isDir = item.is_dir;
            cardEl.dataset.isGallery = item.is_gallery;
            cardEl.dataset.nameNoExt = item.name_no_ext;
            const imgEl = cardClone.querySelector('img');
            const placeholderEl = cardClone.querySelector('.placeholder-text');
            const filenameEl = cardClone.querySelector('.card-filename');
            if (item.cover_filename) {
                imgEl.src = `/api/media/${state.mode}/cover/${encodeURIComponent(item.cover_filename)}`;
                imgEl.style.display = 'block'; placeholderEl.style.display = 'none';
            } else {
                imgEl.style.display = 'none'; placeholderEl.style.display = 'block'; placeholderEl.textContent = item.name_no_ext;
            }
            const icon = item.is_dir ? 'üìÅ' : 'üìÑ';
            filenameEl.textContent = `${icon} ${item.name}`;
            const tagsEl = cardClone.querySelector('.card-tags');
            updateCardTagsDisplay(tagsEl, item.name_no_ext);
            mediaContainer.appendChild(cardClone);
            setTimeout(() => {
                if (currentRenderingId !== state.renderingId) return;
                renderCardsStaggered(items, index + 1, currentRenderingId); 
            }, 15);
        }

        function updateCardTagsDisplay(tagsContainer, itemKey) {
            tagsContainer.innerHTML = '';
            const tags = state.isTagEditMode ? state.tempTagsData[itemKey] || [] : state.tagsData[itemKey] || [];
            const visibleTags = tags.filter(tag => !tag.startsWith('*'));
            if (state.isTagEditMode) {
                visibleTags.forEach(tag => {
                    const unit = document.createElement('div');
                    unit.className = 'tag-edit-unit';
                    const tagEl = document.createElement('span');
                    tagEl.className = 'card-tag';
                    tagEl.textContent = tag;
                    tagEl.style.backgroundColor = '#555';
                    tagEl.style.cursor = 'default';
                    const delBtn = document.createElement('span');
                    delBtn.className = 'del-tag-btn';
                    delBtn.textContent = '√ó';
                    delBtn.onclick = (e) => { e.stopPropagation(); deleteTag(itemKey, tag); };
                    unit.appendChild(tagEl);
                    unit.appendChild(delBtn);
                    tagsContainer.appendChild(unit);
                });
                const addBtn = document.createElement('span');
                addBtn.className = 'add-tag-btn';
                addBtn.textContent = '+';
                addBtn.onclick = (e) => { e.stopPropagation(); addTag(itemKey); };
                tagsContainer.appendChild(addBtn);
                const importBtn = document.createElement('span');
                importBtn.className = 'auto-import-btn';
                importBtn.textContent = 'üîç';
                importBtn.title = '‰ªéDMMËá™Âä®ÂØºÂÖ•Tag';
                importBtn.onclick = (e) => { e.stopPropagation(); autoImportTags(itemKey, importBtn); };
                tagsContainer.appendChild(importBtn);
            } else {
                visibleTags.forEach((tag, tagIndex) => {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'card-tag';
                    tagEl.textContent = tag;
                    tagEl.dataset.tag = tag;
                    const ratio = visibleTags.length > 1 ? tagIndex / (visibleTags.length - 1) : 0;
                    const r = Math.round(95 * (1 - ratio) + 220 * ratio);
                    const g = Math.round(15 * (1 - ratio) + 47 * ratio);
                    const b = Math.round(64 * (1 - ratio) + 2 * ratio);
                    tagEl.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
                    tagEl.onclick = (e) => { e.stopPropagation(); searchInput.value = tag; search(tag, 'tag'); };
                    tagsContainer.appendChild(tagEl);
                });
            }
        }

        function refreshAllCardsTags() {
            document.querySelectorAll('.card').forEach(card => {
                const itemKey = card.dataset.nameNoExt;
                const tagsContainer = card.querySelector('.card-tags');
                if(itemKey && tagsContainer) updateCardTagsDisplay(tagsContainer, itemKey);
            });
        }
        
        // --- Áª¥Êä§ÂäüËÉΩÂáΩÊï∞ ---
        async function enterTagEditMode() {
            if(state.isTagEditMode) return;
            state.isTagEditMode = true;
            state.tempTagsData = JSON.parse(JSON.stringify(state.tagsData));
            editTagsBtn.textContent = "‰øùÂ≠òTag";
            editTagsBtn.style.backgroundColor = 'red';
            maintenanceBtn.textContent = '‰øùÂ≠ò‰∏≠...';
            maintenanceBtn.style.backgroundColor = 'red';
            refreshAllCardsTags();
            maintenanceMenu.style.display = 'none';
        }

        async function saveAndExitTagEditMode() {
            if(!state.isTagEditMode) return;
            const options = { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(state.tempTagsData), clearContentOnLoad: false };
            showLoading(true, false);
            const result = await fetch('/api/tags', options).then(res => res.json()).catch(e => ({status: 'error', message: e.toString()}));
            showLoading(false, false);
            if (result.status === 'success') {
                alert('Tag Â∑≤ÊàêÂäü‰øùÂ≠òÔºÅ');
                state.tagsData = JSON.parse(JSON.stringify(state.tempTagsData));
                state.isTagEditMode = false;
                state.tempTagsData = {};
                editTagsBtn.textContent = "ÁºñËæëTag";
                editTagsBtn.style.backgroundColor = '';
                maintenanceBtn.textContent = 'Áª¥Êä§';
                maintenanceBtn.style.backgroundColor = '';
                refreshAllCardsTags();
            } else {
                alert(`Tag ‰øùÂ≠òÂ§±Êïó: ${result.message}`);
            }
        }

        async function confirmExitTagEditMode() {
            const hasChanges = JSON.stringify(state.tagsData) !== JSON.stringify(state.tempTagsData);
            if (!hasChanges || confirm("ÊÇ®ÊúâÊú™‰øùÂ≠òÁöÑTag‰øÆÊîπÔºåÁ¢∫ÂÆöË¶ÅÊîæÊ£ÑÂóéÔºü")) {
                state.isTagEditMode = false;
                state.tempTagsData = {};
                editTagsBtn.textContent = "ÁºñËæëTag";
                editTagsBtn.style.backgroundColor = '';
                maintenanceBtn.textContent = 'Áª¥Êä§';
                maintenanceBtn.style.backgroundColor = '';
                refreshAllCardsTags();
                return true;
            }
            return false;
        }

        function addTag(itemKey) {
            const newTag = prompt(`ÁÇ∫ "${itemKey}" Ê∑ªÂä†Êñ∞Tag:`);
            if (newTag && newTag.trim()) {
                const tag = newTag.trim();
                if (tag.startsWith('*')) { alert('‰∏çËÉΩÊâãÂä®Ê∑ªÂä†‰ª• "*" ÂºÄÂ§¥ÁöÑÁâπÊÆäTag„ÄÇ'); return; }
                if (!state.tempTagsData[itemKey]) state.tempTagsData[itemKey] = [];
                if (!state.tempTagsData[itemKey].includes(tag)) {
                    state.tempTagsData[itemKey].push(tag);
                    refreshAllCardsTags();
                } else {
                    alert(`Tag "${tag}" Â∑≤ÁªèÂ≠òÂú®„ÄÇ`);
                }
            }
        }

        function deleteTag(itemKey, tagToDelete) {
            if (state.tempTagsData[itemKey]) {
                state.tempTagsData[itemKey] = state.tempTagsData[itemKey].filter(t => t !== tagToDelete);
                if (state.tempTagsData[itemKey].length === 0) delete state.tempTagsData[itemKey];
                refreshAllCardsTags();
            }
        }

        async function autoImportTags(itemKey, buttonEl) {
            if (activeImports[itemKey]) {
                activeImports[itemKey].abort();
                return;
            }
            if (Object.keys(activeImports).length > 0 && !activeImports[itemKey]) {
                alert('ÂÖ∂‰ªñÁöÑÂØºÂÖ•Ê≠£Âú®ËøõË°åÔºåËØ∑ÂÖàÂÆåÊàêÂΩìÂâçÁöÑTagÂØºÂÖ•Êìç‰Ωú„ÄÇ');
                return;
            }
            const originalText = buttonEl.textContent;
            buttonEl.disabled = true;
            buttonEl.textContent = '‚Ä¶';
            const controller = new AbortController();
            activeImports[itemKey] = controller;
            try {
                const response = await fetch('/api/auto_import_tags', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ item_name: itemKey }),
                    signal: controller.signal
                });
                delete activeImports[itemKey];
                const result = await response.json();
                if (result.status === 'success') {
                    if (!state.tempTagsData[itemKey]) state.tempTagsData[itemKey] = [];
                    const existingTags = new Set(state.tempTagsData[itemKey]);
                    let newTagsAdded = 0;
                    result.tags.forEach(tag => {
                        if (!existingTags.has(tag)) {
                            state.tempTagsData[itemKey].push(tag);
                            existingTags.add(tag);
                            newTagsAdded++;
                        }
                    });
                    alert(`ÊàêÂäüÂØºÂÖ• ${newTagsAdded} ‰∏™Êñ∞TagÔºÅ`);
                    refreshAllCardsTags();
                } else {
                    alert(`TagÂØºÂÖ•Â§±Ë¥•: ${result.message}`);
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    alert(`È°πÁõÆ "${itemKey}" ÁöÑÂØºÂÖ•Êìç‰ΩúÂ∑≤ÂèñÊ∂à„ÄÇ`);
                } else {
                    alert("Ëá™Âä®ÂØºÂÖ•ËØ∑Ê±ÇÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÂíåÊúçÂä°Âô®ÊéßÂà∂Âè∞Êó•Âøó„ÄÇ");
                }
            } finally {
                delete activeImports[itemKey];
                buttonEl.disabled = false;
                buttonEl.textContent = originalText;
                refreshAllCardsTags();
            }
        }

        // --- Viewers and Navigation ---
        function openImageViewer(fullPath, mediaPath, itemKey) {
            showLoading(true, false);
            const url = `/api/gallery?mode=${state.mode}&path=${encodeURIComponent(fullPath)}`;
            fetch(url).then(res => res.json()).then(files => {
                showLoading(false, false);
                if (files && !files.error && files.length > 0) {
                    state.gallery = { ...state.gallery, isOpen: true, baseMediaPath: mediaPath, files: files, currentIndex: -1, itemKey: itemKey };
                    imageViewer.classList.add('active');
                    document.body.style.overflow = 'hidden';
                    buildProgressBar();
                    displayImage(0);
                } else { alert('ÈÄôÂÄãÂúñÁâáÈõÜÊòØÁ©∫ÁöÑÊàñËºâÂÖ•Â§±ÊïóÔºÅ'); }
            }).catch(err => { showLoading(false, false); alert('ËºâÂÖ•ÂúñÁâáÈõÜÂ§±ÊïóÔºö' + err); });
        }

        function closeImageViewer() {
            state.gallery.isOpen = false;
            imageViewer.classList.remove('active');
            document.body.style.overflow = 'auto';
            currentImage.src = "";
            currentImage.style.opacity = 0; currentImage.style.transform = 'none';
            currentImage.style.maxWidth = '100%'; currentImage.style.maxHeight = '100%';
            viewerState.rotationAngle = 0;
            if (document.fullscreenElement) { document.exitFullscreen(); }
        }
        
        function displayImage(index) {
            if (!state.gallery.isOpen || state.gallery.isLoading || index < 0 || index >= state.gallery.files.length) return;
            if (state.gallery.currentIndex !== index) recordView(state.gallery.itemKey, index);
            state.gallery.isLoading = true;
            currentImage.style.opacity = 0;
            applyImageViewerTransforms();
            setTimeout(() => {
                const type = 'pages';
                const imageName = state.gallery.files[index];
                const imageUrl = `/api/media/${state.mode}/${type}/${state.gallery.baseMediaPath}/${imageName}`;
                currentImage.src = imageUrl;
                currentImage.onload = () => {
                    currentImage.style.opacity = 1;
                    state.gallery.currentIndex = index;
                    updateProgressBar();
                    preloadNextImage();
                    state.gallery.isLoading = false;
                    applyImageViewerTransforms();
                };
                currentImage.onerror = () => { state.gallery.isLoading = false; }
            }, 200);
        }
        
        function preloadNextImage() {
            const nextIndex = state.gallery.currentIndex + 1;
            if (nextIndex < state.gallery.files.length) {
                const type = 'pages';
                const nextImageName = state.gallery.files[nextIndex];
                const nextImageUrl = `/api/media/${state.mode}/${type}/${state.gallery.baseMediaPath}/${nextImageName}`;
                new Image().src = nextImageUrl;
            }
        }
        
        function changeImage(direction) {
            if (!state.gallery.isOpen) return; 
            const newIndex = state.gallery.currentIndex + direction; 
            displayImage(newIndex);
        }
        
        function buildProgressBar() {
            progressBarContainer.innerHTML = '';
            const pageCount = state.gallery.files.length;
            for (let i = 0; i < pageCount; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'progress-segment-wrapper';
                wrapper.dataset.index = i;
                const label = document.createElement('span');
                label.className = 'progress-label';
                const segment = document.createElement('div');
                segment.className = 'progress-segment';
                if ((i + 1) % 10 === 0 && pageCount > 10) {
                    wrapper.style.flexGrow = 2.2;
                    label.textContent = i + 1;
                }
                wrapper.appendChild(label);
                wrapper.appendChild(segment);
                progressBarContainer.appendChild(wrapper);
            }
            progressBarContainer.addEventListener('click', (e) => {
                e.stopPropagation();
                const wrapper = e.target.closest('.progress-segment-wrapper');
                if (wrapper && wrapper.dataset.index) {
                    const clickedIndex = parseInt(wrapper.dataset.index, 10);
                    displayImage(clickedIndex);
                }
            });
        }
        
        function updateProgressBar() {
            const wrappers = progressBarContainer.children;
            for (let i = 0; i < wrappers.length; i++) {
                const segment = wrappers[i].querySelector('.progress-segment');
                if (segment) segment.classList.toggle('active', i === state.gallery.currentIndex);
            }
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }
        
        function openVideoPlayer(mediaPath) {
            const videoUrl = `/api/media/${state.mode}/video/${mediaPath}`; 
            videoPlayer.classList.add('active'); 
            document.body.style.overflow = 'hidden'; 
            currentVideo.src = videoUrl;
        }
        
        function closeVideoPlayer() {
            videoPlayer.classList.remove('active'); 
            document.body.style.overflow = 'auto'; 
            currentVideo.pause(); 
            currentVideo.src = "";
        }

        async function openEpubViewer(mediaPath) {
            const epubViewer = document.getElementById('epub-viewer');
            const epubArea = document.getElementById('epub-area');
            const epubUrl = `/api/media/${state.mode}/pages/${mediaPath}`;

            // „ÄêÂÖ≥Èó≠ÊåâÈíÆ‰øÆÂ§ç 1„ÄëËé∑ÂèñÂÖ≥Èó≠ÊåâÈíÆÂÖÉÁ¥†
            const closeBtn = epubViewer.querySelector('.close-btn');

            epubArea.innerHTML = '';
            epubViewer.classList.add('active');
            document.body.style.overflow = 'hidden';

            try {
                book = ePub(epubUrl);
                
                rendition = book.renderTo("epub-area", {
                    manager: "default",
                    view: "iframe",
                    width: "100%",  // Let rendition fill the container width
                    height: "100%", // Let rendition fill the container height
                    allowScriptedContent: true,
                    sandbox: "allow-scripts allow-same-origin"
                });
                rendition.hooks.content.register(function(contents) {
                    const stylesheet = contents.document.createElement("style");
                    stylesheet.innerHTML = `
                        /* Reset the container elements inside the EPUB */
                        html, body {
                            width: 100% !important;
                            height: 100% !important;
                            margin: 0 !important;
                            padding: 0 !important;
                            box-sizing: border-box !important;
                        }

                        /* Handle images wrapped in SVG, a common practice in EPUBs */
                        body > svg {
                            width: 100% !important;
                            height: 100% !important;
                            padding: 0 !important;
                            margin: 0 !important;
                        }

                        /* Ensure the image itself fits perfectly */
                        img, svg image {
                            max-width: 100% !important;
                            max-height: 100% !important; /* Use max-height to fit vertically */
                            height: auto !important;
                            object-fit: contain !important; /* Crucial for fitting without cropping */
                            display: block !important;
                            margin: 0 auto !important;
                        }
                    `;
                    contents.document.head.appendChild(stylesheet);
                });
                await rendition.display();

                // „ÄêÂÖ≥Èó≠ÊåâÈíÆ‰øÆÂ§ç 2„ÄëÂú®ÊâìÂºÄÊó∂Ôºå‰∏∫ÂÖ≥Èó≠ÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
                closeBtn.onclick = () => closeEpubViewer();

                // ‰∏∫ÁøªÈ°µÊåâÈíÆÁªëÂÆöÂ∏¶ÊúâÈîôËØØÂ§ÑÁêÜÁöÑ‰∫ã‰ª∂
                document.getElementById('prev-page-btn').onclick = () => {
                    try {
                        if (rendition && typeof rendition.prev === 'function') {
                            rendition.prev();
                        }
                    } catch (e) {
                        console.error("Êó†Ê≥ïÊâßË°å rendition.prev()ÔºåÂèØËÉΩÊòØEPUBÊñá‰ª∂‰∏çÂÖºÂÆπ:", e);
                    }
                };
                document.getElementById('next-page-btn').onclick = () => {
                    try {
                        if (rendition && typeof rendition.next === 'function') {
                            rendition.next();
                        }
                    } catch (e) {
                        console.error("Êó†Ê≥ïÊâßË°å rendition.next()ÔºåÂèØËÉΩÊòØEPUBÊñá‰ª∂‰∏çÂÖºÂÆπ:", e);
                    }
                };

                // ÁªëÂÆöÈîÆÁõò‰∫ã‰ª∂
                epubKeyListenerAbortController = new AbortController();
                document.addEventListener('keydown', handleEpubKeys, { signal: epubKeyListenerAbortController.signal });

            } catch (err) {
                console.error("EPUB rendering failed:", err);
                alert("Âä†ËΩΩ EPUB Êñá‰ª∂Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶ÊúâÊïà‰ª•ÂèäÊéßÂà∂Âè∞ÈîôËØØ„ÄÇ");
                closeEpubViewer();
            }
        }

        function handleEpubKeys(e) {
            if (!rendition) return;
            try {
                if (e.key === "ArrowRight") {
                    if (typeof rendition.next === 'function') rendition.next();
                } else if (e.key === "ArrowLeft") {
                    if (typeof rendition.prev === 'function') rendition.prev();
                }
            } catch (err) {
                console.error("EPUBÈîÆÁõòÂØºËà™Âá∫Èîô:", err);
            }
        }

        function closeEpubViewer() {
            const epubViewer = document.getElementById('epub-viewer');
            const closeBtn = epubViewer.querySelector('.close-btn');

            epubViewer.classList.remove('active');
            document.body.style.overflow = 'auto';

            if (epubKeyListenerAbortController) {
                epubKeyListenerAbortController.abort();
                epubKeyListenerAbortController = null;
            }
            document.getElementById('prev-page-btn').onclick = null;
            document.getElementById('next-page-btn').onclick = null;
            if (closeBtn) {
                closeBtn.onclick = null;
            }

            if (book) {
                book.destroy();
                book = null;
                rendition = null;
            }
        }

        // --- NEW: Album View / Music Player functions ---
        function openAlbumView(fullPath, mediaPath, nameNoExt) {
            const url = `/api/album_details?mode=MUSIC&path=${encodeURIComponent(fullPath)}`;
            fetch(url).then(res => res.json()).then(details => {
                if (details && !details.error && details.tracks.length > 0) {
                    // ÂàùÂßãÂåñÊàñÈáçÁΩÆÊí≠ÊîæÂô®Áä∂ÊÄÅ
                    playerState.currentTracklist = [...details.tracks];
                    playerState.originalTracklist = [...details.tracks];
                    playerState.baseMediaPath = mediaPath;
                    playerState.currentIndex = -1;
                    playerState.isShuffled = false; 
                    playerState.repeatMode = 'ALL';   // ÈªòËÆ§ËÆæÁΩÆ‰∏∫ÂàóË°®Âæ™ÁéØ
                    
                    albumTitleText.textContent = nameNoExt;
                    albumArtImg.src = details.cover_image ? `/api/media/MUSIC/pages/${mediaPath}/${details.cover_image}` : '';
                    albumArtImg.onerror = () => { albumArtImg.src = ''; }; // Â¶ÇÊûúÂ∞ÅÈù¢Âä†ËΩΩÂ§±Ë¥•ÂàôÊ∏ÖÁ©∫
                    
                    buildTracklistUI(details.tracks);
                    albumView.classList.add('active');
                    document.body.style.overflow = 'hidden';
                    updatePlayerControlsUI();
                } else {
                    alert('Ëøô‰∏™‰∏ìËæëÊòØÁ©∫ÁöÑÊàñÂä†ËΩΩÂ§±Ë¥•ÔºÅ');
                }
            });
        }

        function closeAlbumView() {
            albumView.classList.remove('active');
            document.body.style.overflow = 'auto';
            audioPlayer.pause();
            audioPlayer.src = '';
            playerState.isPlaying = false;
        }
        
        function buildTracklistUI(tracks) {
            trackListUI.innerHTML = '';
            tracks.forEach((track, index) => {
                const li = document.createElement('li');
                li.className = 'track-item';
                li.dataset.index = index;
                const trackNum = document.createElement('span');
                trackNum.className = 'track-number';
                trackNum.textContent = index + 1;
                const trackTitleSpan = document.createElement('span');
                trackTitleSpan.className = 'track-title';
                trackTitleSpan.textContent = track.replace(/\.\w+$/, ''); // ÁßªÈô§Êâ©Â±ïÂêç
                li.appendChild(trackNum);
                li.appendChild(trackTitleSpan);
                trackListUI.appendChild(li);
            });
        }
        
        function playTrack(index) {
            // Â¶ÇÊûúÁ¥¢ÂºïË∂äÁïåÔºåÂàôÂÅúÊ≠¢Êí≠Êîæ
            if (index < 0 || index >= playerState.currentTracklist.length) {
                playerState.isPlaying = false;
                playerState.currentIndex = -1;
                audioPlayer.src = '';
                updatePlayerControlsUI();
                // ÂèñÊ∂àÊâÄÊúâÈ´ò‰∫Æ
                document.querySelectorAll('#track-list-ui .track-item.playing').forEach(item => item.classList.remove('playing'));
                return;
            }

            playerState.currentIndex = index;
            const trackName = playerState.currentTracklist[index];
            audioPlayer.src = `/api/media/MUSIC/audio/${playerState.baseMediaPath}/${encodeURIComponent(trackName)}`;
            audioPlayer.play();
            // isPlaying Áä∂ÊÄÅÂ∞ÜÁî± 'play' ‰∫ã‰ª∂ÁõëÂê¨Âô®Êõ¥Êñ∞

            // Êõ¥Êñ∞UIÈ´ò‰∫Æ
            document.querySelectorAll('#track-list-ui .track-item').forEach((item, i) => {
                item.classList.toggle('playing', i === index);
            });
        }
        
        function togglePlayPause() {
            if (playerState.isPlaying) {
                audioPlayer.pause();
            } else {
                if (playerState.currentIndex === -1 && playerState.currentTracklist.length > 0) {
                    playTrack(0); // Â¶ÇÊûú‰ªéÊú™Êí≠ÊîæËøáÔºå‰ªéÁ¨¨‰∏ÄÈ¶ñÂºÄÂßã
                } else {
                    audioPlayer.play();
                }
            }
        }
        function playNextTrack() {
            let nextIndex;
            if (playerState.isShuffled) {
                nextIndex = Math.floor(Math.random() * playerState.currentTracklist.length);
                // ÈÅøÂÖçÂú®ÈöèÊú∫Ê®°Âºè‰∏ãËøûÁª≠Êí≠ÊîæÂêå‰∏ÄÈ¶ñÊ≠å
                if (nextIndex === playerState.currentIndex && playerState.currentTracklist.length > 1) {
                    nextIndex = (nextIndex + 1) % playerState.currentTracklist.length;
                }
            } else {
                nextIndex = playerState.currentIndex + 1;
            }
            
            // Ê£ÄÊü•ÊòØÂê¶Âà∞ËææÂàóË°®Êú´Â∞æ
            if (nextIndex >= playerState.currentTracklist.length && playerState.repeatMode !== 'ALL') {
                playTrack(-1); // ‰º†ÈÄí‰∏Ä‰∏™Êó†ÊïàÁ¥¢Âºï‰ª•ÂÅúÊ≠¢Êí≠Êîæ
            } else {
                // Â¶ÇÊûúÊòØÂàóË°®Âæ™ÁéØÔºåÂàô % ËøêÁÆóÁ¨¶‰ºöËá™Âä®Â§ÑÁêÜË∂äÁïåÈóÆÈ¢ò (‰æãÂ¶Ç 5 % 5 = 0)
                playTrack(nextIndex % playerState.currentTracklist.length);
            }
        }
        
        function playPrevTrack() {
            // Â¶ÇÊûúÊ≠åÊõ≤Â∑≤Êí≠ÊîæË∂ÖËøá3ÁßíÔºåÂàôÈáçÊñ∞Êí≠ÊîæÂΩìÂâçÊ≠åÊõ≤ÔºåÂê¶ÂàôÊí≠Êîæ‰∏ä‰∏ÄÈ¶ñ
            if (audioPlayer.currentTime > 3) {
                playTrack(playerState.currentIndex);
            } else {
                let prevIndex = playerState.currentIndex - 1;
                // Â¶ÇÊûúÊòØÂàóË°®Âæ™ÁéØ‰∏îÂ∑≤ÊòØÁ¨¨‰∏ÄÈ¶ñÔºåÂàôË∑≥Âà∞ÊúÄÂêé‰∏ÄÈ¶ñ
                if (prevIndex < 0 && playerState.repeatMode === 'ALL') {
                    prevIndex = playerState.currentTracklist.length - 1;
                }
                playTrack(prevIndex);
            }
        }

        function handleTrackEnd() {
            // ÂΩì‰∏ÄÈ¶ñÊ≠åÊí≠ÊîæÁªìÊùüÊó∂ÔºåÊ†πÊçÆÂæ™ÁéØÊ®°ÂºèÂÜ≥ÂÆö‰∏ã‰∏ÄÊ≠•
            if (playerState.repeatMode === 'ONE') {
                playTrack(playerState.currentIndex); // ÈáçÊñ∞Êí≠ÊîæÂΩìÂâçÊ≠åÊõ≤
            } else {
                playNextTrack();
            }
        }

        function toggleShuffle() {
            playerState.isShuffled = !playerState.isShuffled;
            const currentTrackName = playerState.currentTracklist[playerState.currentIndex];

            if (playerState.isShuffled) {
                let array = [...playerState.originalTracklist];
                // Fisher-Yates shuffle ÁÆóÊ≥ïÊâì‰π±Êï∞ÁªÑ
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                playerState.currentTracklist = array;
            } else {
                // ÊÅ¢Â§çÂéüÂßãÈ°∫Â∫è
                playerState.currentTracklist = [...playerState.originalTracklist];
            }
            
            buildTracklistUI(playerState.currentTracklist);
            // ÊâæÂà∞ÂΩìÂâçÊ≠åÊõ≤Âú®Êñ∞ÂàóË°®‰∏≠ÁöÑ‰ΩçÁΩÆ
            playerState.currentIndex = playerState.currentTracklist.indexOf(currentTrackName);
            
            // ÈáçÊñ∞È´ò‰∫ÆÊ≠£Âú®Êí≠ÊîæÁöÑÊõ≤ÁõÆ
            if (playerState.currentIndex !== -1) {
                const currentTrackElement = trackListUI.querySelector(`.track-item[data-index='${playerState.currentIndex}']`);
                if (currentTrackElement) {
                    currentTrackElement.classList.add('playing');
                }
            }
            updatePlayerControlsUI();
        }

        function cycleRepeatMode() {
            const modes = ['NONE', 'ALL', 'ONE'];
            let currentModeIndex = modes.indexOf(playerState.repeatMode);
            currentModeIndex = (currentModeIndex + 1) % modes.length;
            playerState.repeatMode = modes[currentModeIndex];
            updatePlayerControlsUI();
        }

        function updatePlayerControlsUI() {
            playPauseBtn.textContent = playerState.isPlaying ? 'ÊöÇÂÅú' : 'Êí≠Êîæ';
            
            shuffleBtn.textContent = playerState.isShuffled ? 'ÈöèÊú∫Â∑≤ÂºÄ' : 'ÈöèÊú∫Â∑≤ÂÖ≥';
            shuffleBtn.classList.toggle('active', playerState.isShuffled);

            repeatBtn.classList.toggle('active', playerState.repeatMode !== 'NONE');
            switch(playerState.repeatMode) {
                case 'NONE':
                    repeatBtn.textContent = 'È°∫Â∫èÊí≠Êîæ';
                    break;
                case 'ALL':
                    repeatBtn.textContent = 'ÂàóË°®Âæ™ÁéØ';
                    break;
                case 'ONE':
                    repeatBtn.textContent = 'ÂçïÊõ≤Âæ™ÁéØ';
                    break;
            }
        }

        async function goBack() {
            if (state.isTagEditMode && !await confirmExitTagEditMode()) return;
            if (state.inSearchMode) {
                state.inSearchMode = false; searchInput.value = '';
                const targetPath = state.pathStack.length > 0 ? state.pathStack[state.pathStack.length - 1] : '';
                browse(targetPath);
                return;
            }
            if (state.pathStack.length > 1) {
                state.pathStack.pop(); 
                const prevPath = state.pathStack[state.pathStack.length - 1]; 
                browse(prevPath); 
            }
        }

        // --- NEW: Anime View functions ---

        function openAnimeView(fullPath, mediaPath, nameNoExt) {
            const url = `/api/anime_details?mode=ANIME&path=${encodeURIComponent(fullPath)}`;
            fetch(url).then(res => res.json()).then(details => {
                if (details && !details.error && details.tree && details.tree.length > 0) {
                    animePlayerState.baseMediaPath = mediaPath;
                    animePlayerState.episodeTree = details.tree;
                    animePlayerState.currentPlayingPath = null;

                    animeTitleText.textContent = nameNoExt;
                    buildEpisodeListUI(details.tree); // Â∞ÜÊñ∞ÁöÑÊ†ëÊï∞ÊçÆ‰º†ÈÄíÁªôÊûÑÂª∫ÂáΩÊï∞

                    animeView.classList.add('active');
                    document.body.style.overflow = 'hidden';

                    // Ëá™Âä®Êí≠ÊîæÊâæÂà∞ÁöÑÁ¨¨‰∏Ä‰∏™ËßÜÈ¢ë
                    const firstVideo = findFirstVideo(details.tree);
                    if (firstVideo) {
                        playEpisode(firstVideo.path, firstVideo.subtitles);
                    }

                } else {
                    alert('Ëøô‰∏™Êñá‰ª∂Â§πÊòØÁ©∫ÁöÑÊàñÂä†ËΩΩÂ§±Ë¥•ÔºÅ');
                }
            });
        }

        function closeAnimeView() {
            animeView.classList.remove('active');
            document.body.style.overflow = 'auto';
            currentAnimeVideo.pause();
            currentAnimeVideo.src = '';
            // ÁßªÈô§ÊóßÁöÑtrackÂÖÉÁ¥†ÔºåÈò≤Ê≠¢ÁºìÂ≠ò
            const oldTrack = currentAnimeVideo.querySelector('track');
            if (oldTrack) oldTrack.remove();
        }

        function buildEpisodeListUI(nodes) {
            episodeListUI.innerHTML = ''; // Ê∏ÖÁ©∫ÊóßÂàóË°®

            // ÈÄíÂΩíÂáΩÊï∞ÔºåÁî®‰∫éÂàõÂª∫ÂàóË°®‰∏≠ÁöÑÊØè‰∏™ËäÇÁÇπÔºàÊñá‰ª∂ÊàñÊñá‰ª∂Â§πÔºâ
            function createNode(node, parentElement) {
                const li = document.createElement('li');
                
                if (node.type === 'directory') {
                    li.className = 'episode-item episode-folder';
                    li.textContent = `üìÅ ${node.name}`; // Ê∑ªÂä†Êñá‰ª∂Â§πÂõæÊ†á
                    li.title = node.name;
                    
                    const childrenUl = document.createElement('ul');
                    childrenUl.style.display = 'none'; // Â≠êÂàóË°®ÈªòËÆ§ÈöêËóè
                    childrenUl.style.paddingLeft = '20px';
                    childrenUl.style.listStyle = 'none';

                    node.children.forEach(childNode => createNode(childNode, childrenUl));
                    
                    li.appendChild(childrenUl);
                    
                    // „ÄêÈáçË¶Å‰øÆÊîπ„ÄëÁßªÈô§‰∫ÜÊ≠§Â§ÑÂçïÁã¨ÁöÑ li.addEventListener('click', ...)

                } else if (node.type === 'video') {
                    // „ÄêÈáçË¶Å‰øÆÊîπ„Äë‰∏∫ËßÜÈ¢ëÈ°πÊ∑ªÂä†‰∫Ü 'episode-video' Á±ª
                    li.className = 'episode-item episode-video';
                    li.textContent = truncateFilename(node.name); // ‰ΩøÁî®Êñ∞ËßÑÂàôÊòæÁ§∫Êñá‰ª∂Âêç
                    li.title = node.name; // Èº†Ê†áÊÇ¨ÂÅúÊó∂ÊòæÁ§∫ÂÆåÊï¥Êñá‰ª∂Âêç
                    
                    li.dataset.videoPath = node.path;
                    if (node.subtitles && node.subtitles.length > 0) {
                        li.dataset.subtitles = JSON.stringify(node.subtitles);
                    }
                    
                    // Â¶ÇÊûúÊòØÂΩìÂâçÊí≠ÊîæÁöÑËßÜÈ¢ëÔºåÊ∑ªÂä†È´ò‰∫Æ
                    if (node.path === animePlayerState.currentPlayingPath) {
                        li.classList.add('playing');
                    }
                }
                
                parentElement.appendChild(li);
            }
            
            nodes.forEach(node => createNode(node, episodeListUI));
        }

        function loadSubtitleTrack(subtitlePath) {
            // ÁßªÈô§ÊâÄÊúâÁé∞ÊúâÁöÑÂ≠óÂπïËΩ®ÈÅìÔºåÁ°Æ‰øùÂπ≤ÂáÄ
            const existingTracks = currentAnimeVideo.querySelectorAll('track');
            existingTracks.forEach(track => track.remove());

            if (!subtitlePath) {
                console.log('[Ë∞ÉËØï] Êó†Â≠óÂπïËΩ®ÈÅìÂèØÂä†ËΩΩ„ÄÇ');
                toggleSubtitleBtn.textContent = 'Êó†ÂèØÁî®Â≠óÂπï';
                toggleSubtitleBtn.disabled = true;
                return;
            }

            const subtitleUrl = `/api/media/ANIME/pages/${animePlayerState.baseMediaPath}/${encodeURIComponent(subtitlePath)}`;
            console.log(`[Ë∞ÉËØï] Ê≠£Âú®Âä†ËΩΩÂ≠óÂπïËΩ®ÈÅì: ${subtitleUrl}`);

            const trackEl = document.createElement('track');
            trackEl.kind = 'subtitles';
            trackEl.label = subtitlePath.split('/').pop(); // ‰ΩøÁî®Êñá‰ª∂Âêç‰Ωú‰∏∫Ê†áÁ≠æ
            trackEl.srclang = 'zh';
            trackEl.src = subtitleUrl;
            trackEl.default = true;

            currentAnimeVideo.appendChild(trackEl);

            // Á≠âÂæÖÊµèËßàÂô®Â§ÑÁêÜÊñ∞ËΩ®ÈÅì
            setTimeout(() => {
                if (currentAnimeVideo.textTracks.length > 0) {
                    // ÊøÄÊ¥ªËØ•ËΩ®ÈÅì
                    currentAnimeVideo.textTracks[0].mode = animePlayerState.areSubtitlesVisible ? 'showing' : 'hidden';
                    console.log(`[Ë∞ÉËØï] Â≠óÂπïËΩ®ÈÅì "${trackEl.label}" Âä†ËΩΩÊàêÂäüÔºåÊ®°Âºè‰∏∫: ${currentAnimeVideo.textTracks[0].mode}`);
                }
            }, 200);

            toggleSubtitleBtn.textContent = animePlayerState.areSubtitlesVisible ? 'ÈöêËóèÂ≠óÂπï' : 'ÊòæÁ§∫Â≠óÂπï';
            toggleSubtitleBtn.disabled = false;
        }

        function playEpisode(videoPath, subtitles = []) {
            if (!videoPath) return;
            
            // --- ËßÜÈ¢ëÂä†ËΩΩÈÄªËæë (‰∏é‰πãÂâçÁ±ª‰ºº) ---
            currentAnimeVideo.onloadedmetadata = null;
            currentAnimeVideo.pause();
            currentAnimeVideo.src = '';
            currentAnimeVideo.load();
            animePlayerState.currentPlayingPath = videoPath;
            currentAnimeVideo.src = `/api/media/ANIME/pages/${animePlayerState.baseMediaPath}/${encodeURIComponent(videoPath)}`;
            
            // --- Êñ∞Â¢ûÔºöÁÆ°ÁêÜÂ≠óÂπïÈÄâÊã©Âô® UI ---
            const selector = document.getElementById('subtitle-selector-btn');
            selector.innerHTML = ''; // Ê∏ÖÁ©∫ÊóßÈÄâÈ°π

            if (subtitles.length > 0) {
                selector.style.display = 'inline-block'; // ÊòæÁ§∫ÈÄâÊã©Âô®
                subtitles.forEach(subPath => {
                    const option = document.createElement('option');
                    option.value = subPath;
                    option.textContent = subPath.split('/').pop(); // ÊòæÁ§∫Êñá‰ª∂Âêç
                    selector.appendChild(option);
                });
                // Ëá™Âä®Âä†ËΩΩÂπ∂ÊòæÁ§∫Á¨¨‰∏Ä‰∏™Â≠óÂπï
                loadSubtitleTrack(subtitles[0]);
            } else {
                selector.style.display = 'none'; // ÈöêËóèÈÄâÊã©Âô®
                // Á°Æ‰øùÊ≤°ÊúâÊÆãÁïôÁöÑÂ≠óÂπïËΩ®ÈÅì
                loadSubtitleTrack(null);
            }
            
            // --- UI Êõ¥Êñ∞ÂíåÊí≠Êîæ ---
            document.querySelectorAll('#episode-list-ui .episode-item.playing').forEach(item => {
                item.classList.remove('playing');
            });
            const playingItem = episodeListUI.querySelector(`li[data-video-path="${CSS.escape(videoPath)}"]`);
            if (playingItem) playingItem.classList.add('playing');
            
            currentAnimeVideo.load();
            currentAnimeVideo.play().catch(error => console.error("ËßÜÈ¢ëÊí≠ÊîæÂ§±Ë¥•:", error));
        }

        function toggleSubtitles() {
            if (!currentAnimeVideo.textTracks || currentAnimeVideo.textTracks.length === 0) {
                alert("ÂΩìÂâçËßÜÈ¢ëÊ≤°ÊúâÊâæÂà∞ÂèØÁî®Â≠óÂπï„ÄÇ");
                return;
            }

            animePlayerState.areSubtitlesVisible = !animePlayerState.areSubtitlesVisible;
            const newMode = animePlayerState.areSubtitlesVisible ? 'showing' : 'hidden';
            currentAnimeVideo.textTracks[0].mode = newMode;

            toggleSubtitleBtn.textContent = animePlayerState.areSubtitlesVisible ? 'ÈöêËóèÂ≠óÂπï' : 'ÊòæÁ§∫Â≠óÂπï';
        }
        
        // --- Event Listeners ---
        backBtn.addEventListener('click', goBack);
        searchBtn.addEventListener('click', () => search(searchInput.value));
        searchInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') search(searchInput.value); });
        
        modeSelector.addEventListener('change', async (e) => {
            if (state.isTagEditMode && !await confirmExitTagEditMode()) {
                e.target.value = state.mode; // Revert dropdown if user cancels
                return;
            }
            state.mode = e.target.value;
            mediaContainer.className = state.mode.toLowerCase() + '-mode';
            state.pathStack = [];
            state.inSearchMode = false;
            browse();
        });

        mediaContainer.addEventListener('click', (e) => {
            const imageWrapper = e.target.closest('.card-image-wrapper');
            if (!imageWrapper) return;
            const card = imageWrapper.closest('.card');
            if (!card) return;
            if (state.isTagEditMode) return;
            recordView(card.dataset.nameNoExt);
            const { path: fullPath, mediaPath, isGallery: isGalleryStr, isDir: isDirStr, nameNoExt } = card.dataset;
            const isGallery = isGalleryStr === 'true';
            const isDir = isDirStr === 'true';
            
            // If it's a directory in MUSIC mode, open the new album view.
            if (isDir && state.mode === 'ANIME') {
                openAnimeView(fullPath, mediaPath, nameNoExt);
            }
            else if (isDir && state.mode === 'MUSIC') {
                openAlbumView(fullPath, mediaPath, nameNoExt);
            }
            else if (isGallery) {
                openImageViewer(fullPath, mediaPath, nameNoExt);
            }
            else if (isDir) {
                browse(fullPath);
            } 
            // It's a file, handle based on mode
            else { 
                const isEpub = fullPath.toLowerCase().endsWith('.epub');
                if (state.mode === 'JAV' || state.mode === 'ANIME') {
                    openVideoPlayer(mediaPath);
                } else if (isEpub) {
                    openEpubViewer(mediaPath);
                }
                else {
                    alert(`ÈªûÊìä‰∫ÜÊ™îÊ°àÔºö${fullPath}\nÊ≠§È°ûÊ™îÊ°àÁöÑÈªûÊìäË°åÁÇ∫Â∞öÊú™ÂÆöÁæ©„ÄÇ`);
                }
            }
        });

        openFolderBtn.addEventListener('click', async () => {
            if (!state.inSearchMode && state.pathStack.length > 0) {
                const currentDir = state.pathStack[state.pathStack.length - 1];
                await fetch(`/api/open_folder?path=${encodeURIComponent(currentDir)}`);
            } else { alert("ÁÑ°Ê≥ïÂú®ÊêúÁ¥¢ÁµêÊûúÈ†ÅÈù¢ÊâìÈñãÁõÆÈåÑ„ÄÇ"); }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (state.gallery.isOpen) closeImageViewer();
                else if (videoPlayer.classList.contains('active')) closeVideoPlayer();
                else if (albumView.classList.contains('active')) closeAlbumView();
                else if (animeView.classList.contains('active')) closeAnimeView();
                else if (document.getElementById('epub-viewer').classList.contains('active')) closeEpubViewer();
                return;
            }
            
            // Âè™Â§ÑÁêÜÂõæÁâáÈòÖËßàÂô®ÁöÑÂ∑¶Âè≥ÁøªÈ°µ
            if (state.gallery.isOpen) {
                if (e.key === 'ArrowRight') {
                    changeImage(1);
                }
                else if (e.key === 'ArrowLeft') {
                    changeImage(-1);
                }
            }
        });
        
        imageContainer.addEventListener('click', () => changeImage(1));
        imageContainer.addEventListener('contextmenu', (e) => { e.preventDefault(); changeImage(-1); });
        
        // Viewer Close Buttons
        imageViewerCloseBtn.addEventListener('click', (e) => { e.stopPropagation(); closeImageViewer(); });
        videoPlayerCloseBtn.addEventListener('click', closeVideoPlayer);
        animeViewCloseBtn.addEventListener('click', closeAnimeView);
        toggleSubtitleBtn.addEventListener('click', toggleSubtitles);
        episodeListUI.addEventListener('click', (e) => {
            // ÊâæÂà∞Áî®Êà∑ÂÆûÈôÖÁÇπÂáªÁöÑÊúÄÂÜÖÂ±ÇÁöÑÂàóË°®È°πÔºàÂèØËÉΩÊòØÊñá‰ª∂Â§πÊàñËßÜÈ¢ëÔºâ
            const clickedItem = e.target.closest('.episode-item');

            // Â¶ÇÊûúÁÇπÂáªÁöÑ‰∏çÊòØÂàóË°®È°πÔºåÂàô‰∏çÊâßË°å‰ªª‰ΩïÊìç‰Ωú
            if (!clickedItem) {
                return;
            }

            // „ÄêÂàÜÊîØÈÄªËæë 1„ÄëÂ¶ÇÊûúÁÇπÂáªÁöÑÊòØ‰∏Ä‰∏™ËßÜÈ¢ëÈ°π
            if (clickedItem.classList.contains('episode-video')) {
                const videoPath = clickedItem.dataset.videoPath;
                const subtitlesAttr = clickedItem.dataset.subtitles;
                const subtitles = subtitlesAttr ? JSON.parse(subtitlesAttr) : [];
                playEpisode(videoPath, subtitles);
            } 
            // „ÄêÂàÜÊîØÈÄªËæë 2„ÄëÂ¶ÇÊûúÁÇπÂáªÁöÑÊòØ‰∏Ä‰∏™Êñá‰ª∂Â§πÈ°π
            else if (clickedItem.classList.contains('episode-folder')) {
                const childrenUl = clickedItem.querySelector('ul');
                if (childrenUl) {
                    const isVisible = childrenUl.style.display === 'block';
                    childrenUl.style.display = isVisible ? 'none' : 'block';
                    clickedItem.classList.toggle('expanded', !isVisible);
                }
            }
        });
        albumViewCloseBtn.addEventListener('click', closeAlbumView);

        fullscreenBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleFullscreen(); });
        document.addEventListener('fullscreenchange', () => { fullscreenBtn.textContent = document.fullscreenElement ? 'ÔÅ¶' : '‚õ∂'; });
        
        document.body.addEventListener('contextmenu', (e) => {
            if (!imageViewer.classList.contains('active') && !videoPlayer.classList.contains('active') && !albumView.classList.contains('active')) {
                e.preventDefault();
                goBack();
            }
        });

        imageViewer.addEventListener('wheel', (e) => {
            e.preventDefault(); e.stopPropagation();
            clearTimeout(wheelDebounceTimeout);
            wheelDebounceTimeout = setTimeout(() => {
                currentImage.style.transition = 'none';
                viewerState.rotationAngle = (viewerState.rotationAngle + (e.deltaY > 0 ? 90 : -90) + 360) % 360;
                applyImageViewerTransforms();
                setTimeout(() => { currentImage.style.transition = ''; }, 50);
            }, 100);
        });

        // Player Event Listeners
        albumViewCloseBtn.addEventListener('click', closeAlbumView);
        playPauseBtn.addEventListener('click', togglePlayPause);
        nextBtn.addEventListener('click', playNextTrack);
        prevBtn.addEventListener('click', playPrevTrack);
        repeatBtn.addEventListener('click', cycleRepeatMode);
        shuffleBtn.addEventListener('click', toggleShuffle);
        
        audioPlayer.addEventListener('ended', handleTrackEnd);
        audioPlayer.addEventListener('play', () => { 
            playerState.isPlaying = true; 
            updatePlayerControlsUI(); 
        });
        audioPlayer.addEventListener('pause', () => { 
            playerState.isPlaying = false; 
            updatePlayerControlsUI(); 
        });

        trackListUI.addEventListener('click', (e) => {
            const trackItem = e.target.closest('.track-item');
            if(trackItem && trackItem.dataset.index) {
                playTrack(parseInt(trackItem.dataset.index, 10));
            }
        });

        // Maintenance menu listeners
        statsBtn.addEventListener('click', () => { window.location.href = '/stats'; });
        maintenanceBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (state.isTagEditMode) {
                saveAndExitTagEditMode();
            } else {
                maintenanceMenu.style.display = maintenanceMenu.style.display === 'block' ? 'none' : 'block';
            }
        });
        document.addEventListener('click', (e) => {
            if (!maintenanceBtn.contains(e.target) && !maintenanceMenu.contains(e.target)) {
                maintenanceMenu.style.display = 'none';
            }
        });
        editTagsBtn.addEventListener('click', () => {
             if (state.isTagEditMode) {
                saveAndExitTagEditMode();
             } else {
                enterTagEditMode();
             }
        });
        generateCoversBtn.addEventListener('click', async () => {
            maintenanceMenu.style.display = 'none';
            if (state.inSearchMode) {
                alert("Ë´ãÂú®Ê≠£Â∏∏ÁöÑË≥áÊñôÂ§æÁÄèË¶ΩÊ®°Âºè‰∏ã‰ΩøÁî®Ê≠§ÂäüËÉΩÔºåËÄå‰∏çÊòØÂú®ÊêúÁ¥¢ÁµêÊûúÈ†ÅÈù¢„ÄÇ");
                return;
            }
            if (confirm(`ÊÇ®Á¢∫ÂÆöË¶ÅÊéÉÊèèÁï∂ÂâçÁõÆÈåÑÔºö\n"${state.currentPath}"\n\n‰∏¶Â∞áÊâæÂà∞ÁöÑÊñ∞Â∞ÅÈù¢ÁîüÊàêÂà∞Â∞çÊáâÁöÑ COVER Ë≥áÊñôÂ§æ‰∏≠ÂóéÔºü`)) {
                const options = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: state.mode, path: state.currentPath }),
                    clearContentOnLoad: false
                };
                const result = await fetchData('/api/generate_covers', options);
                if(result && result.status === 'started'){
                    alert("Â∞ÅÈù¢ÁîüÊàê‰ªªÂãôÂ∑≤Âú®ÂæåÂè∞ÈñãÂßã„ÄÇ\nÂÆåÊàêÂæåÔºåË´ãÊ™¢Êü•Â∞ÅÈù¢ÁõÆÈåÑ‰∏ãÁöÑ 'temp_generated_covers' Êñá‰ª∂Â§æ„ÄÇ");
                } else {
                    alert("ÂïüÂãïÂ∞ÅÈù¢ÁîüÊàê‰ªªÂãôÂ§±Êïó„ÄÇË©≥ÊÉÖË´ãÊü•Áúã‰º∫ÊúçÂô®ÊéßÂà∂Âè∞Êó•Ë™å„ÄÇ");
                }
            }
        });

        subtitleSelector.addEventListener('change', (event) => {
            const newSubtitlePath = event.target.value;
            if (newSubtitlePath) {
                // ÂΩìÁî®Êà∑ÈÄâÊã©Êñ∞Â≠óÂπïÊó∂ÔºåË∞ÉÁî® loadSubtitleTrack Êù•ÂàáÊç¢
                loadSubtitleTrack(newSubtitlePath);
            }
        });

        // --- Initial load ---
        async function initialize() {
            state.tagsData = await fetch('/api/tags').then(res => res.json()).catch(() => ({}));
            browse();
        }
        initialize();
        
    });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
</body>
</html>