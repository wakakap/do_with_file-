<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文件系统媒体浏览器</title>
    <link rel="manifest" href="{{ url_for('static', filename='manifest.json') }}">
    <style>
        :root { --background-color: #242424; --text-color: #FFFFFF; --button-color: #3B3B3B; --button-hover-color: #888888; --card-background-color: #494141; --card-border-color: #333333; --nav-text-color: #AAAAAA; --placeholder-text-color: #CCCCCC; --font-family: 'Microsoft YaHei', 'Segoe UI', 'WenQuanYi Micro Hei', sans-serif; --label-start-r: 95; --label-start-g: 15; --label-start-b: 64; --label-end-r: 220; --label-end-g: 47; --label-end-b: 2; }
        body { background-color: var(--background-color); color: var(--text-color); font-family: var(--font-family); margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        .header-container, .nav-frame { padding: 10px 20px; flex-shrink: 0; }
        .header { display: flex; justify-content: space-between; align-items: center; }
        .header-controls { display: flex; gap: 10px; align-items: center; }
        .header-right-controls { display: flex; gap: 10px; align-items: center; position: relative; }
        .button, input[type="text"], select { background-color: var(--button-color); color: var(--text-color); border: 1px solid var(--card-border-color); border-radius: 6px; padding: 8px 12px; font-size: 14px; cursor: pointer; transition: background-color 0.2s; }
        .button:hover, select:hover { background-color: var(--button-hover-color); }
        input[type="text"] { width: 300px; }
        input[type="text"]::placeholder { color: var(--placeholder-text-color); }
        select { -webkit-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23%23AAAAAA%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22/%3E%3C/svg%3E'); background-repeat: no-repeat; background-position: right 12px center; background-size: 10px auto; padding-right: 30px; }
        .nav-frame { color: var(--nav-text-color); font-size: 12px; padding-top: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .main-content { flex-grow: 1; overflow-y: auto; padding: 0 15px 15px 15px; }
        #media-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(230px, 1fr)); gap: 12px; }
        #media-container.jav-mode, #media-container.anime-mode { grid-template-columns: repeat(auto-fill, minmax(380px, 1fr)); }
        .card { background-color: var(--card-background-color); border: 1px solid var(--card-border-color); border-radius: 8px; overflow: hidden; display: flex; flex-direction: column; }
        .card-image-wrapper { width: 100%; background-color: #1E1E1E; display: flex; justify-content: center; align-items: center; color: var(--nav-text-color); font-size: 16px; text-align: center; padding: 10px; box-sizing: border-box; cursor: pointer; }
        .manga-mode .card-image-wrapper, .novel-mode .card-image-wrapper, .other-mode .card-image-wrapper, .anime-mode .card-image-wrapper { aspect-ratio: 2 / 3; }
        .music-mode .card-image-wrapper { aspect-ratio: 1 / 1; }
        .jav-mode .card-image-wrapper { aspect-ratio: 800 / 538; }
        .card-image-wrapper img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .card-info { padding: 8px 12px; flex-grow: 1; display: flex; flex-direction: column; gap: 8px; cursor: default; }
        .card-filename { font-size: 14px; word-break: break-all; }
        .card-tags { display: flex; flex-wrap: wrap; gap: 6px; min-height: 24px; }
        .card-tag { font-size: 12px; padding: 2px 6px; border-radius: 5px; color: white; cursor: pointer; transition: transform 0.1s; }
        .card-tag:hover { transform: scale(1.05); }
        .tag-edit-unit { display: flex; align-items: center; background-color: #555; border-radius: 5px; }
        .del-tag-btn { font-size: 12px; padding: 1px 5px; margin-left:2px; background-color: #C00000; color: white; border-radius: 0 5px 5px 0; cursor: pointer; }
        .del-tag-btn:hover { background-color: red; }
        .add-tag-btn { font-size: 14px; width: 22px; height: 22px; padding: 0; line-height:22px; text-align:center; background-color: #3B3B3B; cursor:pointer; border-radius:5px; }
        .add-tag-btn:hover{ background-color: #888; }
        .open-folder-btn { position: fixed; bottom: 20px; right: 20px; z-index: 50; }
        #loading-indicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; display: none; z-index: 2000; }
        #maintenance-menu { display: none; position: absolute; top: 100%; right: 0; background-color: var(--card-background-color); border: 1px solid var(--card-border-color); border-radius: 6px; z-index: 100; padding: 5px; min-width: 120px; }
        #maintenance-menu .button { width: 100%; text-align: left; margin-bottom: 5px; }
        #maintenance-menu .button:last-child { margin-bottom: 0; }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .overlay.active { display: flex; }
        .overlay .close-btn { position: absolute; top: 26px; left: 80px; font-size: 34px; color: white; cursor: pointer; z-index: 1010; text-shadow: 0 0 5px black; line-height: 1;}
        .overlay .close-btn:hover { color: #ff4d4d; }
        #image-viewer { flex-direction: row; padding: 20px; box-sizing: border-box; }
        #image-viewer .image-container { flex-grow: 1; display: flex; justify-content: center; align-items: center; height: 100%; padding: 0; }
        #image-viewer .image-container img { max-width: 100%; max-height: 100%; object-fit: contain; opacity: 0; transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #image-viewer .progress-bar { width: 70px; height: 100%; display: flex; flex-direction: column; justify-content: center; padding: 0; box-sizing: border-box; gap: 1px; cursor: pointer; }
        .progress-segment-wrapper { display: flex; align-items: center; justify-content: flex-end; flex-grow: 1; }
        .progress-label { width: 30px; font-size: 10px; color: #cccccc; text-align: right; padding-right: 5px; flex-shrink: 0; }
        #image-viewer .progress-segment { flex-grow: 1; max-width: 15px; align-self: stretch; background-color: #555; border-radius: 2px; transition: background-color 0.2s; }
        #image-viewer .progress-segment.active { background-color: #3B8ED0; }
        #video-player video { max-width: 95vw; max-height: 95vh; outline: none; }
        #fullscreen-btn { position: absolute; top: 25px; left: 30px; font-size: 28px; color: white; cursor: pointer; z-index: 1010; text-shadow: 0 0 5px black; }
        #fullscreen-btn:hover { color: #87cefa; }
        .add-tag-btn, .auto-import-btn { font-size: 14px; width: 22px; height: 22px; padding: 0; line-height:22px; text-align:center; background-color: #3B3B3B; cursor:pointer; border-radius:5px; display: inline-block; margin-left: 4px; vertical-align: middle; }
        .add-tag-btn:hover, .auto-import-btn:hover { background-color: #888; }
        .auto-import-btn[disabled] { cursor: not-allowed; background-color: #555; }
        /* --- START: EPUB Viewer Style Overhaul --- */
        #epub-viewer {
            /* Use Flexbox for robust vertical layout */
            flex-direction: column;
            justify-content: space-between; /* Pushes top/bottom bars to edges */
            padding: 20px;
            box-sizing: border-box;
            height: 100vh; 
            box-sizing: border-box;
        }
        #epub-top-bar, #epub-bottom-bar {
            flex-shrink: 0; /* Prevent bars from shrinking */
            display: flex;
            align-items: center;
            width: 100%;
            padding: 10px 0;
        }
        #epub-top-bar {
            justify-content: flex-start; /* Align close button to the left */
        }
        #epub-bottom-bar {
            justify-content: center; /* Center navigation buttons */
            gap: 15px; /* Space between buttons */
        }
        /* Override the default close button position for this specific viewer */
        #epub-viewer .close-btn {
            position: static; /* Remove absolute positioning */
            font-size: 28px;
            line-height: 1;
        }
        #epub-area-wrapper {
            flex-grow: 1; 
            width: 100%;
            max-width: 900px; 
            margin: 0 auto;
            overflow: hidden;
            display: flex;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #epub-area {
            width: 100%;
            height: 100%;
            background-color: white;
        }
        #prev-page-btn, #next-page-btn {
            font-size: 14px;
            padding: 8px 20px;
        }

        /* --- NEW: Album View and Music Player Styles --- */
        #album-view {
            flex-direction: row;
            align-items: flex-start;
            padding: 80px 40px 40px 40px;
            gap: 40px;
            background: linear-gradient(rgba(0,0,0,0.5), #121212 40%);
        }
        #album-view .album-info {
            flex-shrink: 0;
            width: 300px;
            text-align: center;
        }
        #album-view .album-art {
            width: 100%;
            aspect-ratio: 1 / 1;
            object-fit: cover;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            background-color: #333;
        }
        #album-view .album-title {
            margin-top: 20px;
            font-size: 24px;
            font-weight: bold;
        }
        #album-view .track-list-container {
            flex-grow: 1;
            height: calc(100vh - 220px); /* 减去padding和控制条的高度 */
            overflow-y: auto;
        }
        #album-view .track-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #album-view .track-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #album-view .track-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        #album-view .track-item.playing {
            background-color: rgba(40, 150, 255, 0.2);
            color: #70b8ff;
        }
        .track-number {
            font-size: 16px;
            color: #aaa;
            width: 25px;
            text-align: right;
        }
        .track-title {
            font-size: 16px;
        }

        #music-player-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 90px;
            background-color: #181818;
            border-top: 1px solid #282828;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 10px 0;
            box-sizing: border-box;
            z-index: 1020; /* 确保在album-view浮层之上 */
        }
        .control-buttons {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .control-button {
            background-color: transparent;
            border: 1px solid #555;
            border-radius: 5px;
            color: #b3b3b3;
            cursor: pointer;
            padding: 8px 16px;
            min-width: 90px;
            text-align: center;
            font-size: 14px; /* 统一字体大小 */
            transition: color 0.2s, border-color 0.2s, background-color 0.2s;
        }
        .control-button:hover {
            color: #fff;
            border-color: #888;
        }
        .control-button.play-pause {
            font-size: 14px; /* 统一字体大小 */
            min-width: 100px;
        }
        .control-button.active {
            color: #1DB954; /* Spotify Green */
            border-color: #1DB954;
        }
        #current-audio-player {
            width: 80%;
            max-width: 700px;
            margin-top: 10px;
        }
        /* --- NEW: Anime View Styles --- */
        #anime-view {
            flex-direction: row;
            align-items: stretch;
            padding: 40px;
            gap: 20px;
            background: #181818;
            height: 100vh; /* 将容器高度限制为整个视口高度 */
            box-sizing: border-box; /* 确保 padding 不会增加额外的高度 */
        }
        .anime-player-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        #anime-video-wrapper {
            flex-grow: 1;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            overflow: hidden;
        }
        #current-anime-video {
            width: 100%;
            height: 100%;
            outline: none;
        }
        #anime-controls-wrapper {
            flex-shrink: 0;
            padding-top: 15px;
            display: flex;
            gap: 10px;
        }
        .episode-list-container {
            flex-shrink: 0;
            width: 200px;
            background-color: #121212;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            max-height: calc(100% - 45px); /* 设置最大高度，减去标题的近似高度和边距 */
        }
        #anime-title-text {
            margin: 0 0 15px 0;
            padding-bottom: 15px;
            border-bottom: 1px solid #282828;
            font-size: 20px;
        }
        .episode-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            flex-grow: 1;
        }
        .episode-item {
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .episode-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .episode-item.playing {
            background-color: rgba(40, 150, 255, 0.2);
            color: #70b8ff;
            font-weight: bold;
        }

    </style>
</head>
<body>
    <div class="header-container">
        <div class="header">
            <div class="header-controls">
                <select id="mode-selector" class="button">
                    <option value="MANGA">MANGA</option>
                    <option value="JAV">JAV</option>
                    <option value="ANIME">ANIME</option>
                    <option value="MUSIC">MUSIC</option>
                    <option value="NOVEL">NOVEL</option>
                    <option value="OTHER">OTHER</option>
                </select>
                <input type="text" id="search-input" placeholder="输入关键词搜索...">
                <button id="search-btn" class="button">搜索</button>
            </div>
            <div class="header-right-controls">
                <button id="stats-btn" class="button">统计</button>
                <div class="maintenance-container" style="position: relative;">
                    <button id="maintenance-btn" class="button">维护</button>
                    <div id="maintenance-menu">
                        <button id="generate-covers-btn" class="button">生成封面</button>
                        <button id="edit-tags-btn" class="button">编辑Tag</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="nav-frame">
        <button id="back-btn" class="button" style="margin-right: 10px; display: none;">返回</button>
        <span id="current-path-label">正在加载...</span>
    </div>
    <div class="main-content">
        <div id="media-container" class="manga-mode"></div>
    </div>
    <button id="open-folder-btn" class="button open-folder-btn">打开所在目录</button>
    <div id="loading-indicator">正在加载...</div>

    <div id="image-viewer" class="overlay">
        <span id="fullscreen-btn">⛶</span>
        <span class="close-btn">&times;</span>
        <div class="image-container">
            <img id="current-image" src="" alt="viewer image">
        </div>
        <div id="progress-bar-container" class="progress-bar"></div>
    </div>
    <div id="epub-viewer" class="overlay">
        <div id="epub-top-bar">
            <span class="close-btn">&times;</span>
        </div>

        <div id="epub-area-wrapper">
            <div id="epub-area"></div>
        </div>

        <div id="epub-bottom-bar">
            <button id="prev-page-btn" class="button">&lt; 上一页</button>
            <button id="next-page-btn" class="button">下一页 &gt;</button>
        </div>
    </div>
    <div id="video-player" class="overlay">
        <span class="close-btn">&times;</span>
        <video id="current-video" controls autoplay></video>
    </div>
    <div id="album-view" class="overlay">
        <span class="close-btn">&times;</span>
        <div class="album-info">
            <img id="album-art-img" src="" class="album-art">
            <h2 id="album-title-text" class="album-title"></h2>
        </div>
        <div class="track-list-container">
            <ol id="track-list-ui" class="track-list"></ol>
        </div>
        <div id="music-player-controls">
            <div class="control-buttons">
                <button id="shuffle-btn" class="control-button" title="随机播放">随机已关</button>
                <button id="prev-btn" class="control-button">上一首</button>
                <button id="play-pause-btn" class="control-button play-pause">播放</button>
                <button id="next-btn" class="control-button">下一首</button>
                <button id="repeat-btn" class="control-button" title="循环模式">顺序播放</button>
            </div>
            <audio id="current-audio-player" controls></audio>
        </div>
    </div>
    <div id="anime-view" class="overlay">
        <span class="close-btn">&times;</span>
        <div class="anime-player-container">
            <div id="anime-video-wrapper">
                <video id="current-anime-video" controls autoplay>
                    <track kind="subtitles" srclang="zh" label="Default Subtitles">
                </video>
            </div>
            <div id="anime-controls-wrapper">
                 <button id="toggle-subtitle-btn" class="button">隐藏字幕</button>
                 <select id="subtitle-selector-btn" class="button" style="display: none;"></select>
            </div>
        </div>
        <div class="episode-list-container">
            <h2 id="anime-title-text"></h2>
            <ol id="episode-list-ui" class="episode-list"></ol>
        </div>
    </div>
    <template id="card-template">
        <div class="card">
            <div class="card-image-wrapper">
                <img>
                <span class="placeholder-text"></span>
            </div>
            <div class="card-info">
                <div class="card-filename"></div>
                <div class="card-tags"></div>
            </div>
        </div>
    </template>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- 元素选择器 ---
        const modeSelector = document.getElementById('mode-selector');
        const searchInput = document.getElementById('search-input');
        const searchBtn = document.getElementById('search-btn');
        const pathLabel = document.getElementById('current-path-label');
        const mediaContainer = document.getElementById('media-container');
        const cardTemplate = document.getElementById('card-template');
        const openFolderBtn = document.getElementById('open-folder-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        const backBtn = document.getElementById('back-btn');
        // Viewers
        const imageViewer = document.getElementById('image-viewer');
        const imageContainer = imageViewer.querySelector('.image-container');
        const progressBarContainer = document.getElementById('progress-bar-container');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const currentImage = document.getElementById('current-image');
        const imageViewerCloseBtn = imageViewer.querySelector('.close-btn');
        const videoPlayer = document.getElementById('video-player');
        const currentVideo = document.getElementById('current-video');
        const videoPlayerCloseBtn = videoPlayer.querySelector('.close-btn');
        const animeView = document.getElementById('anime-view');
        const animeViewCloseBtn = animeView.querySelector('.close-btn');
        const currentAnimeVideo = document.getElementById('current-anime-video');
        const animeTitleText = document.getElementById('anime-title-text');
        const episodeListUI = document.getElementById('episode-list-ui');
        const toggleSubtitleBtn = document.getElementById('toggle-subtitle-btn');
        // New Music Player / Album View
        const albumView = document.getElementById('album-view');
        const albumViewCloseBtn = albumView.querySelector('.close-btn');
        const albumArtImg = document.getElementById('album-art-img');
        const albumTitleText = document.getElementById('album-title-text');
        const trackListUI = document.getElementById('track-list-ui');
        const audioPlayer = document.getElementById('current-audio-player');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const nextBtn = document.getElementById('next-btn');
        const prevBtn = document.getElementById('prev-btn');
        const shuffleBtn = document.getElementById('shuffle-btn');
        const repeatBtn = document.getElementById('repeat-btn');
        // Maintenance
        const statsBtn = document.getElementById('stats-btn');
        const maintenanceBtn = document.getElementById('maintenance-btn');
        const maintenanceMenu = document.getElementById('maintenance-menu');
        const generateCoversBtn = document.getElementById('generate-covers-btn');
        const editTagsBtn = document.getElementById('edit-tags-btn');
        // ANIME Player
        const subtitleSelector = document.getElementById('subtitle-selector-btn');

        // --- 状态对象 ---
        let state = {
            mode: 'MANGA',
            currentPath: '',
            pathStack: [],
            inSearchMode: false,
            isTagEditMode: false,
            renderingId: 0,
            tagsData: {},
            tempTagsData: {},
            gallery: { isOpen: false, baseMediaPath: '', itemKey: '', files: [], currentIndex: 0, isLoading: false }
        };
        let playerState = {
            currentTracklist: [],
            originalTracklist: [],
            baseMediaPath: '',
            currentIndex: -1,
            isPlaying: false,
            isShuffled: false,
            repeatMode: 'NONE', // NONE, ALL, ONE
        };
        let animePlayerState = {
            baseMediaPath: '',
            episodeTree: [], // 新增：存储整个剧集树
            currentPlayingPath: null, // 新增：存储当前播放视频的路径
            areSubtitlesVisible: true,
        };
        let activeImports = {};
        let viewerState = { rotationAngle: 0 };
        let wheelDebounceTimeout = null;
        let book = null;
        let rendition = null;
        let epubKeyListenerAbortController = null; 

        // --- 核心功能函数 ---
        function truncateFilename(name) {
            const nameNoExt = name.replace(/\.\w+$/, '');
            const match = nameNoExt.match(/\d+/); // 查找第一个数字序列

            if (!match) {
                // 如果没有数字，提供一个备用截断方案
                return nameNoExt.length > 20 ? nameNoExt.substring(0, 17) + '...' : nameNoExt;
            }

            const numberStr = match[0];
            const index = match.index;
            
            // 计算截取范围：数字前后各5个字符
            const start = Math.max(0, index - 5);
            const end = Math.min(nameNoExt.length, index + numberStr.length + 5);
            
            let result = nameNoExt.substring(start, end);
            
            // 如果前面或后面有更多字符，则添加省略号
            if (start > 0) {
                result = '…' + result;
            }
            if (end < nameNoExt.length) {
                result = result + '…';
            }
            return result;
        }

        function findFirstVideo(nodes) {
            for (const node of nodes) {
                if (node.type === 'video') {
                    return node;
                }
                if (node.type === 'directory') {
                    const found = findFirstVideo(node.children);
                    if (found) {
                        return found;
                    }
                }
            }
            return null;
        }

        function applyImageViewerTransforms() {
            if (!state.gallery.isOpen) return;
            const { rotationAngle } = viewerState;
            let scale = 1;
            if (rotationAngle === 90 || rotationAngle === 270) {
                currentImage.style.maxWidth = 'none';
                currentImage.style.maxHeight = 'none';
                const img = currentImage;
                const container = imageContainer;
                if (img.naturalWidth > 0 && img.naturalHeight > 0) {
                    const scaleX = container.clientWidth / img.naturalHeight;
                    const scaleY = container.clientHeight / img.naturalWidth;
                    scale = Math.min(scaleX, scaleY);
                }
            } else {
                currentImage.style.maxWidth = '100%';
                currentImage.style.maxHeight = '100%';
            }
            currentImage.style.transformOrigin = `center center`;
            currentImage.style.transform = `rotate(${rotationAngle}deg) scale(${scale})`;
        }
        
        function showLoading(isLoading, clearContent = true) {
            loadingIndicator.style.display = isLoading ? 'block' : 'none';
            if (isLoading && clearContent) { mediaContainer.innerHTML = ''; }
        }

        async function fetchData(url, options = {}) {
            const clear = options.clearContentOnLoad !== false;
            showLoading(true, clear);
            try {
                const response = await fetch(url, options);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error("Fetch error:", error);
                mediaContainer.innerHTML = `<p style="padding:20px;">載入失敗: ${error.message}</p>`;
                return null;
            } finally {
                showLoading(false, clear);
            }
        }
        
        async function browse(path = '') {
            state.renderingId++;
            if(state.isTagEditMode && !await confirmExitTagEditMode()) return;
            state.inSearchMode = false; searchInput.value = '';
            const url = path ? `/api/browse?mode=${state.mode}&path=${encodeURIComponent(path)}` : `/api/browse?mode=${state.mode}`;
            const data = await fetchData(url, { clearContentOnLoad: true });
            if (data && data.items) {
                state.currentPath = data.current_path;
                if (!state.pathStack.length || state.pathStack[state.pathStack.length - 1] !== data.current_path) { state.pathStack.push(data.current_path); }
                pathLabel.textContent = `模式: ${state.mode} | ${state.currentPath}`;
                backBtn.style.display = state.pathStack.length > 1 ? 'inline-block' : 'none';
                mediaContainer.innerHTML = '';
                renderCardsStaggered(data.items, 0, state.renderingId);
            }
        }
        
        async function search(query, type = 'keyword') {
            if (!query) return;
            state.renderingId++;
            if(state.isTagEditMode && !await confirmExitTagEditMode()) return;
            state.inSearchMode = true;
            const url = `/api/search?mode=${state.mode}&q=${encodeURIComponent(query)}&type=${encodeURIComponent(type)}`;
            const data = await fetchData(url, { clearContentOnLoad: true });
            if (data && data.items) {
                const searchLabel = type === 'tag' ? `標籤搜索: "${query}"` : `關鍵詞搜索: "${query}"`;
                pathLabel.textContent = searchLabel;
                backBtn.style.display = 'inline-block';
                mediaContainer.innerHTML = '';
                renderCardsStaggered(data.items, 0, state.renderingId);
            }
        }

        async function recordView(itemKey, pageIndex = null) {
            if (state.isTagEditMode) return;
            try {
                fetch('/api/record_view', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ item_key: itemKey, page_index: pageIndex }),
                });
            } catch (error) {
                console.error('Failed to record view:', error);
            }
        }
        
        // --- 卡片渲染和 Tag UI ---
        function renderCardsStaggered(items, index = 0, currentRenderingId) {
            if (currentRenderingId !== state.renderingId || index >= items.length) return;
            const item = items[index];
            const cardClone = cardTemplate.content.cloneNode(true);
            const cardEl = cardClone.querySelector('.card');
            cardEl.dataset.path = item.full_path;
            cardEl.dataset.mediaPath = item.media_path;
            cardEl.dataset.isDir = item.is_dir;
            cardEl.dataset.isGallery = item.is_gallery;
            cardEl.dataset.nameNoExt = item.name_no_ext;
            const imgEl = cardClone.querySelector('img');
            const placeholderEl = cardClone.querySelector('.placeholder-text');
            const filenameEl = cardClone.querySelector('.card-filename');
            if (item.cover_filename) {
                imgEl.src = `/api/media/${state.mode}/cover/${encodeURIComponent(item.cover_filename)}`;
                imgEl.style.display = 'block'; placeholderEl.style.display = 'none';
            } else {
                imgEl.style.display = 'none'; placeholderEl.style.display = 'block'; placeholderEl.textContent = item.name_no_ext;
            }
            const icon = item.is_dir ? '📁' : '📄';
            filenameEl.textContent = `${icon} ${item.name}`;
            const tagsEl = cardClone.querySelector('.card-tags');
            updateCardTagsDisplay(tagsEl, item.name_no_ext);
            mediaContainer.appendChild(cardClone);
            setTimeout(() => {
                if (currentRenderingId !== state.renderingId) return;
                renderCardsStaggered(items, index + 1, currentRenderingId); 
            }, 15);
        }

        function updateCardTagsDisplay(tagsContainer, itemKey) {
            tagsContainer.innerHTML = '';
            const tags = state.isTagEditMode ? state.tempTagsData[itemKey] || [] : state.tagsData[itemKey] || [];
            const visibleTags = tags.filter(tag => !tag.startsWith('*'));
            if (state.isTagEditMode) {
                visibleTags.forEach(tag => {
                    const unit = document.createElement('div');
                    unit.className = 'tag-edit-unit';
                    const tagEl = document.createElement('span');
                    tagEl.className = 'card-tag';
                    tagEl.textContent = tag;
                    tagEl.style.backgroundColor = '#555';
                    tagEl.style.cursor = 'default';
                    const delBtn = document.createElement('span');
                    delBtn.className = 'del-tag-btn';
                    delBtn.textContent = '×';
                    delBtn.onclick = (e) => { e.stopPropagation(); deleteTag(itemKey, tag); };
                    unit.appendChild(tagEl);
                    unit.appendChild(delBtn);
                    tagsContainer.appendChild(unit);
                });
                const addBtn = document.createElement('span');
                addBtn.className = 'add-tag-btn';
                addBtn.textContent = '+';
                addBtn.onclick = (e) => { e.stopPropagation(); addTag(itemKey); };
                tagsContainer.appendChild(addBtn);
                const importBtn = document.createElement('span');
                importBtn.className = 'auto-import-btn';
                importBtn.textContent = '🔍';
                importBtn.title = '从DMM自动导入Tag';
                importBtn.onclick = (e) => { e.stopPropagation(); autoImportTags(itemKey, importBtn); };
                tagsContainer.appendChild(importBtn);
            } else {
                visibleTags.forEach((tag, tagIndex) => {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'card-tag';
                    tagEl.textContent = tag;
                    tagEl.dataset.tag = tag;
                    const ratio = visibleTags.length > 1 ? tagIndex / (visibleTags.length - 1) : 0;
                    const r = Math.round(95 * (1 - ratio) + 220 * ratio);
                    const g = Math.round(15 * (1 - ratio) + 47 * ratio);
                    const b = Math.round(64 * (1 - ratio) + 2 * ratio);
                    tagEl.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
                    tagEl.onclick = (e) => { e.stopPropagation(); searchInput.value = tag; search(tag, 'tag'); };
                    tagsContainer.appendChild(tagEl);
                });
            }
        }

        function refreshAllCardsTags() {
            document.querySelectorAll('.card').forEach(card => {
                const itemKey = card.dataset.nameNoExt;
                const tagsContainer = card.querySelector('.card-tags');
                if(itemKey && tagsContainer) updateCardTagsDisplay(tagsContainer, itemKey);
            });
        }
        
        // --- 维护功能函数 ---
        async function enterTagEditMode() {
            if(state.isTagEditMode) return;
            state.isTagEditMode = true;
            state.tempTagsData = JSON.parse(JSON.stringify(state.tagsData));
            editTagsBtn.textContent = "保存Tag";
            editTagsBtn.style.backgroundColor = 'red';
            maintenanceBtn.textContent = '保存中...';
            maintenanceBtn.style.backgroundColor = 'red';
            refreshAllCardsTags();
            maintenanceMenu.style.display = 'none';
        }

        async function saveAndExitTagEditMode() {
            if(!state.isTagEditMode) return;
            const options = { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(state.tempTagsData), clearContentOnLoad: false };
            showLoading(true, false);
            const result = await fetch('/api/tags', options).then(res => res.json()).catch(e => ({status: 'error', message: e.toString()}));
            showLoading(false, false);
            if (result.status === 'success') {
                alert('Tag 已成功保存！');
                state.tagsData = JSON.parse(JSON.stringify(state.tempTagsData));
                state.isTagEditMode = false;
                state.tempTagsData = {};
                editTagsBtn.textContent = "编辑Tag";
                editTagsBtn.style.backgroundColor = '';
                maintenanceBtn.textContent = '维护';
                maintenanceBtn.style.backgroundColor = '';
                refreshAllCardsTags();
            } else {
                alert(`Tag 保存失敗: ${result.message}`);
            }
        }

        async function confirmExitTagEditMode() {
            const hasChanges = JSON.stringify(state.tagsData) !== JSON.stringify(state.tempTagsData);
            if (!hasChanges || confirm("您有未保存的Tag修改，確定要放棄嗎？")) {
                state.isTagEditMode = false;
                state.tempTagsData = {};
                editTagsBtn.textContent = "编辑Tag";
                editTagsBtn.style.backgroundColor = '';
                maintenanceBtn.textContent = '维护';
                maintenanceBtn.style.backgroundColor = '';
                refreshAllCardsTags();
                return true;
            }
            return false;
        }

        function addTag(itemKey) {
            const newTag = prompt(`為 "${itemKey}" 添加新Tag:`);
            if (newTag && newTag.trim()) {
                const tag = newTag.trim();
                if (tag.startsWith('*')) { alert('不能手动添加以 "*" 开头的特殊Tag。'); return; }
                if (!state.tempTagsData[itemKey]) state.tempTagsData[itemKey] = [];
                if (!state.tempTagsData[itemKey].includes(tag)) {
                    state.tempTagsData[itemKey].push(tag);
                    refreshAllCardsTags();
                } else {
                    alert(`Tag "${tag}" 已经存在。`);
                }
            }
        }

        function deleteTag(itemKey, tagToDelete) {
            if (state.tempTagsData[itemKey]) {
                state.tempTagsData[itemKey] = state.tempTagsData[itemKey].filter(t => t !== tagToDelete);
                if (state.tempTagsData[itemKey].length === 0) delete state.tempTagsData[itemKey];
                refreshAllCardsTags();
            }
        }

        async function autoImportTags(itemKey, buttonEl) {
            if (activeImports[itemKey]) {
                activeImports[itemKey].abort();
                return;
            }
            if (Object.keys(activeImports).length > 0 && !activeImports[itemKey]) {
                alert('其他的导入正在进行，请先完成当前的Tag导入操作。');
                return;
            }
            const originalText = buttonEl.textContent;
            buttonEl.disabled = true;
            buttonEl.textContent = '…';
            const controller = new AbortController();
            activeImports[itemKey] = controller;
            try {
                const response = await fetch('/api/auto_import_tags', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ item_name: itemKey }),
                    signal: controller.signal
                });
                delete activeImports[itemKey];
                const result = await response.json();
                if (result.status === 'success') {
                    if (!state.tempTagsData[itemKey]) state.tempTagsData[itemKey] = [];
                    const existingTags = new Set(state.tempTagsData[itemKey]);
                    let newTagsAdded = 0;
                    result.tags.forEach(tag => {
                        if (!existingTags.has(tag)) {
                            state.tempTagsData[itemKey].push(tag);
                            existingTags.add(tag);
                            newTagsAdded++;
                        }
                    });
                    alert(`成功导入 ${newTagsAdded} 个新Tag！`);
                    refreshAllCardsTags();
                } else {
                    alert(`Tag导入失败: ${result.message}`);
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    alert(`项目 "${itemKey}" 的导入操作已取消。`);
                } else {
                    alert("自动导入请求失败，请检查网络连接和服务器控制台日志。");
                }
            } finally {
                delete activeImports[itemKey];
                buttonEl.disabled = false;
                buttonEl.textContent = originalText;
                refreshAllCardsTags();
            }
        }

        // --- Viewers and Navigation ---
        function openImageViewer(fullPath, mediaPath, itemKey) {
            showLoading(true, false);
            const url = `/api/gallery?mode=${state.mode}&path=${encodeURIComponent(fullPath)}`;
            fetch(url).then(res => res.json()).then(files => {
                showLoading(false, false);
                if (files && !files.error && files.length > 0) {
                    state.gallery = { ...state.gallery, isOpen: true, baseMediaPath: mediaPath, files: files, currentIndex: -1, itemKey: itemKey };
                    imageViewer.classList.add('active');
                    document.body.style.overflow = 'hidden';
                    buildProgressBar();
                    displayImage(0);
                } else { alert('這個圖片集是空的或載入失敗！'); }
            }).catch(err => { showLoading(false, false); alert('載入圖片集失敗：' + err); });
        }

        function closeImageViewer() {
            state.gallery.isOpen = false;
            imageViewer.classList.remove('active');
            document.body.style.overflow = 'auto';
            currentImage.src = "";
            currentImage.style.opacity = 0; currentImage.style.transform = 'none';
            currentImage.style.maxWidth = '100%'; currentImage.style.maxHeight = '100%';
            viewerState.rotationAngle = 0;
            if (document.fullscreenElement) { document.exitFullscreen(); }
        }
        
        function displayImage(index) {
            if (!state.gallery.isOpen || state.gallery.isLoading || index < 0 || index >= state.gallery.files.length) return;
            if (state.gallery.currentIndex !== index) recordView(state.gallery.itemKey, index);
            state.gallery.isLoading = true;
            currentImage.style.opacity = 0;
            applyImageViewerTransforms();
            setTimeout(() => {
                const type = 'pages';
                const imageName = state.gallery.files[index];
                const imageUrl = `/api/media/${state.mode}/${type}/${state.gallery.baseMediaPath}/${imageName}`;
                currentImage.src = imageUrl;
                currentImage.onload = () => {
                    currentImage.style.opacity = 1;
                    state.gallery.currentIndex = index;
                    updateProgressBar();
                    preloadNextImage();
                    state.gallery.isLoading = false;
                    applyImageViewerTransforms();
                };
                currentImage.onerror = () => { state.gallery.isLoading = false; }
            }, 200);
        }
        
        function preloadNextImage() {
            const nextIndex = state.gallery.currentIndex + 1;
            if (nextIndex < state.gallery.files.length) {
                const type = 'pages';
                const nextImageName = state.gallery.files[nextIndex];
                const nextImageUrl = `/api/media/${state.mode}/${type}/${state.gallery.baseMediaPath}/${nextImageName}`;
                new Image().src = nextImageUrl;
            }
        }
        
        function changeImage(direction) {
            if (!state.gallery.isOpen) return; 
            const newIndex = state.gallery.currentIndex + direction; 
            displayImage(newIndex);
        }
        
        function buildProgressBar() {
            progressBarContainer.innerHTML = '';
            const pageCount = state.gallery.files.length;
            for (let i = 0; i < pageCount; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'progress-segment-wrapper';
                wrapper.dataset.index = i;
                const label = document.createElement('span');
                label.className = 'progress-label';
                const segment = document.createElement('div');
                segment.className = 'progress-segment';
                if ((i + 1) % 10 === 0 && pageCount > 10) {
                    wrapper.style.flexGrow = 2.2;
                    label.textContent = i + 1;
                }
                wrapper.appendChild(label);
                wrapper.appendChild(segment);
                progressBarContainer.appendChild(wrapper);
            }
            progressBarContainer.addEventListener('click', (e) => {
                e.stopPropagation();
                const wrapper = e.target.closest('.progress-segment-wrapper');
                if (wrapper && wrapper.dataset.index) {
                    const clickedIndex = parseInt(wrapper.dataset.index, 10);
                    displayImage(clickedIndex);
                }
            });
        }
        
        function updateProgressBar() {
            const wrappers = progressBarContainer.children;
            for (let i = 0; i < wrappers.length; i++) {
                const segment = wrappers[i].querySelector('.progress-segment');
                if (segment) segment.classList.toggle('active', i === state.gallery.currentIndex);
            }
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }
        
        function openVideoPlayer(mediaPath) {
            const videoUrl = `/api/media/${state.mode}/video/${mediaPath}`; 
            videoPlayer.classList.add('active'); 
            document.body.style.overflow = 'hidden'; 
            currentVideo.src = videoUrl;
        }
        
        function closeVideoPlayer() {
            videoPlayer.classList.remove('active'); 
            document.body.style.overflow = 'auto'; 
            currentVideo.pause(); 
            currentVideo.src = "";
        }

        async function openEpubViewer(mediaPath) {
            const epubViewer = document.getElementById('epub-viewer');
            const epubArea = document.getElementById('epub-area');
            const epubUrl = `/api/media/${state.mode}/pages/${mediaPath}`;

            // 【关闭按钮修复 1】获取关闭按钮元素
            const closeBtn = epubViewer.querySelector('.close-btn');

            epubArea.innerHTML = '';
            epubViewer.classList.add('active');
            document.body.style.overflow = 'hidden';

            try {
                book = ePub(epubUrl);
                
                rendition = book.renderTo("epub-area", {
                    manager: "default",
                    view: "iframe",
                    width: "100%",  // Let rendition fill the container width
                    height: "100%", // Let rendition fill the container height
                    allowScriptedContent: true,
                    sandbox: "allow-scripts allow-same-origin"
                });
                rendition.hooks.content.register(function(contents) {
                    const stylesheet = contents.document.createElement("style");
                    stylesheet.innerHTML = `
                        /* Reset the container elements inside the EPUB */
                        html, body {
                            width: 100% !important;
                            height: 100% !important;
                            margin: 0 !important;
                            padding: 0 !important;
                            box-sizing: border-box !important;
                        }

                        /* Handle images wrapped in SVG, a common practice in EPUBs */
                        body > svg {
                            width: 100% !important;
                            height: 100% !important;
                            padding: 0 !important;
                            margin: 0 !important;
                        }

                        /* Ensure the image itself fits perfectly */
                        img, svg image {
                            max-width: 100% !important;
                            max-height: 100% !important; /* Use max-height to fit vertically */
                            height: auto !important;
                            object-fit: contain !important; /* Crucial for fitting without cropping */
                            display: block !important;
                            margin: 0 auto !important;
                        }
                    `;
                    contents.document.head.appendChild(stylesheet);
                });
                await rendition.display();

                // 【关闭按钮修复 2】在打开时，为关闭按钮绑定事件
                closeBtn.onclick = () => closeEpubViewer();

                // 为翻页按钮绑定带有错误处理的事件
                document.getElementById('prev-page-btn').onclick = () => {
                    try {
                        if (rendition && typeof rendition.prev === 'function') {
                            rendition.prev();
                        }
                    } catch (e) {
                        console.error("无法执行 rendition.prev()，可能是EPUB文件不兼容:", e);
                    }
                };
                document.getElementById('next-page-btn').onclick = () => {
                    try {
                        if (rendition && typeof rendition.next === 'function') {
                            rendition.next();
                        }
                    } catch (e) {
                        console.error("无法执行 rendition.next()，可能是EPUB文件不兼容:", e);
                    }
                };

                // 绑定键盘事件
                epubKeyListenerAbortController = new AbortController();
                document.addEventListener('keydown', handleEpubKeys, { signal: epubKeyListenerAbortController.signal });

            } catch (err) {
                console.error("EPUB rendering failed:", err);
                alert("加载 EPUB 文件失败，请检查文件是否有效以及控制台错误。");
                closeEpubViewer();
            }
        }

        function handleEpubKeys(e) {
            if (!rendition) return;
            try {
                if (e.key === "ArrowRight") {
                    if (typeof rendition.next === 'function') rendition.next();
                } else if (e.key === "ArrowLeft") {
                    if (typeof rendition.prev === 'function') rendition.prev();
                }
            } catch (err) {
                console.error("EPUB键盘导航出错:", err);
            }
        }

        function closeEpubViewer() {
            const epubViewer = document.getElementById('epub-viewer');
            const closeBtn = epubViewer.querySelector('.close-btn');

            epubViewer.classList.remove('active');
            document.body.style.overflow = 'auto';

            if (epubKeyListenerAbortController) {
                epubKeyListenerAbortController.abort();
                epubKeyListenerAbortController = null;
            }
            document.getElementById('prev-page-btn').onclick = null;
            document.getElementById('next-page-btn').onclick = null;
            if (closeBtn) {
                closeBtn.onclick = null;
            }

            if (book) {
                book.destroy();
                book = null;
                rendition = null;
            }
        }

        // --- NEW: Album View / Music Player functions ---
        function openAlbumView(fullPath, mediaPath, nameNoExt) {
            const url = `/api/album_details?mode=MUSIC&path=${encodeURIComponent(fullPath)}`;
            fetch(url).then(res => res.json()).then(details => {
                if (details && !details.error && details.tracks.length > 0) {
                    // 初始化或重置播放器状态
                    playerState.currentTracklist = [...details.tracks];
                    playerState.originalTracklist = [...details.tracks];
                    playerState.baseMediaPath = mediaPath;
                    playerState.currentIndex = -1;
                    playerState.isShuffled = false; 
                    playerState.repeatMode = 'ALL';   // 默认设置为列表循环
                    
                    albumTitleText.textContent = nameNoExt;
                    albumArtImg.src = details.cover_image ? `/api/media/MUSIC/pages/${mediaPath}/${details.cover_image}` : '';
                    albumArtImg.onerror = () => { albumArtImg.src = ''; }; // 如果封面加载失败则清空
                    
                    buildTracklistUI(details.tracks);
                    albumView.classList.add('active');
                    document.body.style.overflow = 'hidden';
                    updatePlayerControlsUI();
                } else {
                    alert('这个专辑是空的或加载失败！');
                }
            });
        }

        function closeAlbumView() {
            albumView.classList.remove('active');
            document.body.style.overflow = 'auto';
            audioPlayer.pause();
            audioPlayer.src = '';
            playerState.isPlaying = false;
        }
        
        function buildTracklistUI(tracks) {
            trackListUI.innerHTML = '';
            tracks.forEach((track, index) => {
                const li = document.createElement('li');
                li.className = 'track-item';
                li.dataset.index = index;
                const trackNum = document.createElement('span');
                trackNum.className = 'track-number';
                trackNum.textContent = index + 1;
                const trackTitleSpan = document.createElement('span');
                trackTitleSpan.className = 'track-title';
                trackTitleSpan.textContent = track.replace(/\.\w+$/, ''); // 移除扩展名
                li.appendChild(trackNum);
                li.appendChild(trackTitleSpan);
                trackListUI.appendChild(li);
            });
        }
        
        function playTrack(index) {
            // 如果索引越界，则停止播放
            if (index < 0 || index >= playerState.currentTracklist.length) {
                playerState.isPlaying = false;
                playerState.currentIndex = -1;
                audioPlayer.src = '';
                updatePlayerControlsUI();
                // 取消所有高亮
                document.querySelectorAll('#track-list-ui .track-item.playing').forEach(item => item.classList.remove('playing'));
                return;
            }

            playerState.currentIndex = index;
            const trackName = playerState.currentTracklist[index];
            audioPlayer.src = `/api/media/MUSIC/audio/${playerState.baseMediaPath}/${encodeURIComponent(trackName)}`;
            audioPlayer.play();
            // isPlaying 状态将由 'play' 事件监听器更新

            // 更新UI高亮
            document.querySelectorAll('#track-list-ui .track-item').forEach((item, i) => {
                item.classList.toggle('playing', i === index);
            });
        }
        
        function togglePlayPause() {
            if (playerState.isPlaying) {
                audioPlayer.pause();
            } else {
                if (playerState.currentIndex === -1 && playerState.currentTracklist.length > 0) {
                    playTrack(0); // 如果从未播放过，从第一首开始
                } else {
                    audioPlayer.play();
                }
            }
        }
        function playNextTrack() {
            let nextIndex;
            if (playerState.isShuffled) {
                nextIndex = Math.floor(Math.random() * playerState.currentTracklist.length);
                // 避免在随机模式下连续播放同一首歌
                if (nextIndex === playerState.currentIndex && playerState.currentTracklist.length > 1) {
                    nextIndex = (nextIndex + 1) % playerState.currentTracklist.length;
                }
            } else {
                nextIndex = playerState.currentIndex + 1;
            }
            
            // 检查是否到达列表末尾
            if (nextIndex >= playerState.currentTracklist.length && playerState.repeatMode !== 'ALL') {
                playTrack(-1); // 传递一个无效索引以停止播放
            } else {
                // 如果是列表循环，则 % 运算符会自动处理越界问题 (例如 5 % 5 = 0)
                playTrack(nextIndex % playerState.currentTracklist.length);
            }
        }
        
        function playPrevTrack() {
            // 如果歌曲已播放超过3秒，则重新播放当前歌曲，否则播放上一首
            if (audioPlayer.currentTime > 3) {
                playTrack(playerState.currentIndex);
            } else {
                let prevIndex = playerState.currentIndex - 1;
                // 如果是列表循环且已是第一首，则跳到最后一首
                if (prevIndex < 0 && playerState.repeatMode === 'ALL') {
                    prevIndex = playerState.currentTracklist.length - 1;
                }
                playTrack(prevIndex);
            }
        }

        function handleTrackEnd() {
            // 当一首歌播放结束时，根据循环模式决定下一步
            if (playerState.repeatMode === 'ONE') {
                playTrack(playerState.currentIndex); // 重新播放当前歌曲
            } else {
                playNextTrack();
            }
        }

        function toggleShuffle() {
            playerState.isShuffled = !playerState.isShuffled;
            const currentTrackName = playerState.currentTracklist[playerState.currentIndex];

            if (playerState.isShuffled) {
                let array = [...playerState.originalTracklist];
                // Fisher-Yates shuffle 算法打乱数组
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                playerState.currentTracklist = array;
            } else {
                // 恢复原始顺序
                playerState.currentTracklist = [...playerState.originalTracklist];
            }
            
            buildTracklistUI(playerState.currentTracklist);
            // 找到当前歌曲在新列表中的位置
            playerState.currentIndex = playerState.currentTracklist.indexOf(currentTrackName);
            
            // 重新高亮正在播放的曲目
            if (playerState.currentIndex !== -1) {
                const currentTrackElement = trackListUI.querySelector(`.track-item[data-index='${playerState.currentIndex}']`);
                if (currentTrackElement) {
                    currentTrackElement.classList.add('playing');
                }
            }
            updatePlayerControlsUI();
        }

        function cycleRepeatMode() {
            const modes = ['NONE', 'ALL', 'ONE'];
            let currentModeIndex = modes.indexOf(playerState.repeatMode);
            currentModeIndex = (currentModeIndex + 1) % modes.length;
            playerState.repeatMode = modes[currentModeIndex];
            updatePlayerControlsUI();
        }

        function updatePlayerControlsUI() {
            playPauseBtn.textContent = playerState.isPlaying ? '暂停' : '播放';
            
            shuffleBtn.textContent = playerState.isShuffled ? '随机已开' : '随机已关';
            shuffleBtn.classList.toggle('active', playerState.isShuffled);

            repeatBtn.classList.toggle('active', playerState.repeatMode !== 'NONE');
            switch(playerState.repeatMode) {
                case 'NONE':
                    repeatBtn.textContent = '顺序播放';
                    break;
                case 'ALL':
                    repeatBtn.textContent = '列表循环';
                    break;
                case 'ONE':
                    repeatBtn.textContent = '单曲循环';
                    break;
            }
        }

        async function goBack() {
            if (state.isTagEditMode && !await confirmExitTagEditMode()) return;
            if (state.inSearchMode) {
                state.inSearchMode = false; searchInput.value = '';
                const targetPath = state.pathStack.length > 0 ? state.pathStack[state.pathStack.length - 1] : '';
                browse(targetPath);
                return;
            }
            if (state.pathStack.length > 1) {
                state.pathStack.pop(); 
                const prevPath = state.pathStack[state.pathStack.length - 1]; 
                browse(prevPath); 
            }
        }

        // --- NEW: Anime View functions ---

        function openAnimeView(fullPath, mediaPath, nameNoExt) {
            const url = `/api/anime_details?mode=ANIME&path=${encodeURIComponent(fullPath)}`;
            fetch(url).then(res => res.json()).then(details => {
                if (details && !details.error && details.tree && details.tree.length > 0) {
                    animePlayerState.baseMediaPath = mediaPath;
                    animePlayerState.episodeTree = details.tree;
                    animePlayerState.currentPlayingPath = null;

                    animeTitleText.textContent = nameNoExt;
                    buildEpisodeListUI(details.tree); // 将新的树数据传递给构建函数

                    animeView.classList.add('active');
                    document.body.style.overflow = 'hidden';

                    // 自动播放找到的第一个视频
                    const firstVideo = findFirstVideo(details.tree);
                    if (firstVideo) {
                        playEpisode(firstVideo.path, firstVideo.subtitles);
                    }

                } else {
                    alert('这个文件夹是空的或加载失败！');
                }
            });
        }

        function closeAnimeView() {
            animeView.classList.remove('active');
            document.body.style.overflow = 'auto';
            currentAnimeVideo.pause();
            currentAnimeVideo.src = '';
            // 移除旧的track元素，防止缓存
            const oldTrack = currentAnimeVideo.querySelector('track');
            if (oldTrack) oldTrack.remove();
        }

        function buildEpisodeListUI(nodes) {
            episodeListUI.innerHTML = ''; // 清空旧列表

            // 递归函数，用于创建列表中的每个节点（文件或文件夹）
            function createNode(node, parentElement) {
                const li = document.createElement('li');
                
                if (node.type === 'directory') {
                    li.className = 'episode-item episode-folder';
                    li.textContent = `📁 ${node.name}`; // 添加文件夹图标
                    li.title = node.name;
                    
                    const childrenUl = document.createElement('ul');
                    childrenUl.style.display = 'none'; // 子列表默认隐藏
                    childrenUl.style.paddingLeft = '20px';
                    childrenUl.style.listStyle = 'none';

                    node.children.forEach(childNode => createNode(childNode, childrenUl));
                    
                    li.appendChild(childrenUl);
                    
                    // 【重要修改】移除了此处单独的 li.addEventListener('click', ...)

                } else if (node.type === 'video') {
                    // 【重要修改】为视频项添加了 'episode-video' 类
                    li.className = 'episode-item episode-video';
                    li.textContent = truncateFilename(node.name); // 使用新规则显示文件名
                    li.title = node.name; // 鼠标悬停时显示完整文件名
                    
                    li.dataset.videoPath = node.path;
                    if (node.subtitles && node.subtitles.length > 0) {
                        li.dataset.subtitles = JSON.stringify(node.subtitles);
                    }
                    
                    // 如果是当前播放的视频，添加高亮
                    if (node.path === animePlayerState.currentPlayingPath) {
                        li.classList.add('playing');
                    }
                }
                
                parentElement.appendChild(li);
            }
            
            nodes.forEach(node => createNode(node, episodeListUI));
        }

        function loadSubtitleTrack(subtitlePath) {
            // 移除所有现有的字幕轨道，确保干净
            const existingTracks = currentAnimeVideo.querySelectorAll('track');
            existingTracks.forEach(track => track.remove());

            if (!subtitlePath) {
                console.log('[调试] 无字幕轨道可加载。');
                toggleSubtitleBtn.textContent = '无可用字幕';
                toggleSubtitleBtn.disabled = true;
                return;
            }

            const subtitleUrl = `/api/media/ANIME/pages/${animePlayerState.baseMediaPath}/${encodeURIComponent(subtitlePath)}`;
            console.log(`[调试] 正在加载字幕轨道: ${subtitleUrl}`);

            const trackEl = document.createElement('track');
            trackEl.kind = 'subtitles';
            trackEl.label = subtitlePath.split('/').pop(); // 使用文件名作为标签
            trackEl.srclang = 'zh';
            trackEl.src = subtitleUrl;
            trackEl.default = true;

            currentAnimeVideo.appendChild(trackEl);

            // 等待浏览器处理新轨道
            setTimeout(() => {
                if (currentAnimeVideo.textTracks.length > 0) {
                    // 激活该轨道
                    currentAnimeVideo.textTracks[0].mode = animePlayerState.areSubtitlesVisible ? 'showing' : 'hidden';
                    console.log(`[调试] 字幕轨道 "${trackEl.label}" 加载成功，模式为: ${currentAnimeVideo.textTracks[0].mode}`);
                }
            }, 200);

            toggleSubtitleBtn.textContent = animePlayerState.areSubtitlesVisible ? '隐藏字幕' : '显示字幕';
            toggleSubtitleBtn.disabled = false;
        }

        function playEpisode(videoPath, subtitles = []) {
            if (!videoPath) return;
            
            // --- 视频加载逻辑 (与之前类似) ---
            currentAnimeVideo.onloadedmetadata = null;
            currentAnimeVideo.pause();
            currentAnimeVideo.src = '';
            currentAnimeVideo.load();
            animePlayerState.currentPlayingPath = videoPath;
            currentAnimeVideo.src = `/api/media/ANIME/pages/${animePlayerState.baseMediaPath}/${encodeURIComponent(videoPath)}`;
            
            // --- 新增：管理字幕选择器 UI ---
            const selector = document.getElementById('subtitle-selector-btn');
            selector.innerHTML = ''; // 清空旧选项

            if (subtitles.length > 0) {
                selector.style.display = 'inline-block'; // 显示选择器
                subtitles.forEach(subPath => {
                    const option = document.createElement('option');
                    option.value = subPath;
                    option.textContent = subPath.split('/').pop(); // 显示文件名
                    selector.appendChild(option);
                });
                // 自动加载并显示第一个字幕
                loadSubtitleTrack(subtitles[0]);
            } else {
                selector.style.display = 'none'; // 隐藏选择器
                // 确保没有残留的字幕轨道
                loadSubtitleTrack(null);
            }
            
            // --- UI 更新和播放 ---
            document.querySelectorAll('#episode-list-ui .episode-item.playing').forEach(item => {
                item.classList.remove('playing');
            });
            const playingItem = episodeListUI.querySelector(`li[data-video-path="${CSS.escape(videoPath)}"]`);
            if (playingItem) playingItem.classList.add('playing');
            
            currentAnimeVideo.load();
            currentAnimeVideo.play().catch(error => console.error("视频播放失败:", error));
        }

        function toggleSubtitles() {
            if (!currentAnimeVideo.textTracks || currentAnimeVideo.textTracks.length === 0) {
                alert("当前视频没有找到可用字幕。");
                return;
            }

            animePlayerState.areSubtitlesVisible = !animePlayerState.areSubtitlesVisible;
            const newMode = animePlayerState.areSubtitlesVisible ? 'showing' : 'hidden';
            currentAnimeVideo.textTracks[0].mode = newMode;

            toggleSubtitleBtn.textContent = animePlayerState.areSubtitlesVisible ? '隐藏字幕' : '显示字幕';
        }
        
        // --- Event Listeners ---
        backBtn.addEventListener('click', goBack);
        searchBtn.addEventListener('click', () => search(searchInput.value));
        searchInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') search(searchInput.value); });
        
        modeSelector.addEventListener('change', async (e) => {
            if (state.isTagEditMode && !await confirmExitTagEditMode()) {
                e.target.value = state.mode; // Revert dropdown if user cancels
                return;
            }
            state.mode = e.target.value;
            mediaContainer.className = state.mode.toLowerCase() + '-mode';
            state.pathStack = [];
            state.inSearchMode = false;
            browse();
        });

        mediaContainer.addEventListener('click', (e) => {
            const imageWrapper = e.target.closest('.card-image-wrapper');
            if (!imageWrapper) return;
            const card = imageWrapper.closest('.card');
            if (!card) return;
            if (state.isTagEditMode) return;
            recordView(card.dataset.nameNoExt);
            const { path: fullPath, mediaPath, isGallery: isGalleryStr, isDir: isDirStr, nameNoExt } = card.dataset;
            const isGallery = isGalleryStr === 'true';
            const isDir = isDirStr === 'true';
            
            // If it's a directory in MUSIC mode, open the new album view.
            if (isDir && state.mode === 'ANIME') {
                openAnimeView(fullPath, mediaPath, nameNoExt);
            }
            else if (isDir && state.mode === 'MUSIC') {
                openAlbumView(fullPath, mediaPath, nameNoExt);
            }
            else if (isGallery) {
                openImageViewer(fullPath, mediaPath, nameNoExt);
            }
            else if (isDir) {
                browse(fullPath);
            } 
            // It's a file, handle based on mode
            else { 
                const isEpub = fullPath.toLowerCase().endsWith('.epub');
                if (state.mode === 'JAV' || state.mode === 'ANIME') {
                    openVideoPlayer(mediaPath);
                } else if (isEpub) {
                    openEpubViewer(mediaPath);
                }
                else {
                    alert(`點擊了檔案：${fullPath}\n此類檔案的點擊行為尚未定義。`);
                }
            }
        });

        openFolderBtn.addEventListener('click', async () => {
            if (!state.inSearchMode && state.pathStack.length > 0) {
                const currentDir = state.pathStack[state.pathStack.length - 1];
                await fetch(`/api/open_folder?path=${encodeURIComponent(currentDir)}`);
            } else { alert("無法在搜索結果頁面打開目錄。"); }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (state.gallery.isOpen) closeImageViewer();
                else if (videoPlayer.classList.contains('active')) closeVideoPlayer();
                else if (albumView.classList.contains('active')) closeAlbumView();
                else if (animeView.classList.contains('active')) closeAnimeView();
                else if (document.getElementById('epub-viewer').classList.contains('active')) closeEpubViewer();
                return;
            }
            
            // 只处理图片阅览器的左右翻页
            if (state.gallery.isOpen) {
                if (e.key === 'ArrowRight') {
                    changeImage(1);
                }
                else if (e.key === 'ArrowLeft') {
                    changeImage(-1);
                }
            }
        });
        
        imageContainer.addEventListener('click', () => changeImage(1));
        imageContainer.addEventListener('contextmenu', (e) => { e.preventDefault(); changeImage(-1); });
        
        // Viewer Close Buttons
        imageViewerCloseBtn.addEventListener('click', (e) => { e.stopPropagation(); closeImageViewer(); });
        videoPlayerCloseBtn.addEventListener('click', closeVideoPlayer);
        animeViewCloseBtn.addEventListener('click', closeAnimeView);
        toggleSubtitleBtn.addEventListener('click', toggleSubtitles);
        episodeListUI.addEventListener('click', (e) => {
            // 找到用户实际点击的最内层的列表项（可能是文件夹或视频）
            const clickedItem = e.target.closest('.episode-item');

            // 如果点击的不是列表项，则不执行任何操作
            if (!clickedItem) {
                return;
            }

            // 【分支逻辑 1】如果点击的是一个视频项
            if (clickedItem.classList.contains('episode-video')) {
                const videoPath = clickedItem.dataset.videoPath;
                const subtitlesAttr = clickedItem.dataset.subtitles;
                const subtitles = subtitlesAttr ? JSON.parse(subtitlesAttr) : [];
                playEpisode(videoPath, subtitles);
            } 
            // 【分支逻辑 2】如果点击的是一个文件夹项
            else if (clickedItem.classList.contains('episode-folder')) {
                const childrenUl = clickedItem.querySelector('ul');
                if (childrenUl) {
                    const isVisible = childrenUl.style.display === 'block';
                    childrenUl.style.display = isVisible ? 'none' : 'block';
                    clickedItem.classList.toggle('expanded', !isVisible);
                }
            }
        });
        albumViewCloseBtn.addEventListener('click', closeAlbumView);

        fullscreenBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleFullscreen(); });
        document.addEventListener('fullscreenchange', () => { fullscreenBtn.textContent = document.fullscreenElement ? '' : '⛶'; });
        
        document.body.addEventListener('contextmenu', (e) => {
            if (!imageViewer.classList.contains('active') && !videoPlayer.classList.contains('active') && !albumView.classList.contains('active')) {
                e.preventDefault();
                goBack();
            }
        });

        imageViewer.addEventListener('wheel', (e) => {
            e.preventDefault(); e.stopPropagation();
            clearTimeout(wheelDebounceTimeout);
            wheelDebounceTimeout = setTimeout(() => {
                currentImage.style.transition = 'none';
                viewerState.rotationAngle = (viewerState.rotationAngle + (e.deltaY > 0 ? 90 : -90) + 360) % 360;
                applyImageViewerTransforms();
                setTimeout(() => { currentImage.style.transition = ''; }, 50);
            }, 100);
        });

        // Player Event Listeners
        albumViewCloseBtn.addEventListener('click', closeAlbumView);
        playPauseBtn.addEventListener('click', togglePlayPause);
        nextBtn.addEventListener('click', playNextTrack);
        prevBtn.addEventListener('click', playPrevTrack);
        repeatBtn.addEventListener('click', cycleRepeatMode);
        shuffleBtn.addEventListener('click', toggleShuffle);
        
        audioPlayer.addEventListener('ended', handleTrackEnd);
        audioPlayer.addEventListener('play', () => { 
            playerState.isPlaying = true; 
            updatePlayerControlsUI(); 
        });
        audioPlayer.addEventListener('pause', () => { 
            playerState.isPlaying = false; 
            updatePlayerControlsUI(); 
        });

        trackListUI.addEventListener('click', (e) => {
            const trackItem = e.target.closest('.track-item');
            if(trackItem && trackItem.dataset.index) {
                playTrack(parseInt(trackItem.dataset.index, 10));
            }
        });

        // Maintenance menu listeners
        statsBtn.addEventListener('click', () => { window.location.href = '/stats'; });
        maintenanceBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (state.isTagEditMode) {
                saveAndExitTagEditMode();
            } else {
                maintenanceMenu.style.display = maintenanceMenu.style.display === 'block' ? 'none' : 'block';
            }
        });
        document.addEventListener('click', (e) => {
            if (!maintenanceBtn.contains(e.target) && !maintenanceMenu.contains(e.target)) {
                maintenanceMenu.style.display = 'none';
            }
        });
        editTagsBtn.addEventListener('click', () => {
             if (state.isTagEditMode) {
                saveAndExitTagEditMode();
             } else {
                enterTagEditMode();
             }
        });
        generateCoversBtn.addEventListener('click', async () => {
            maintenanceMenu.style.display = 'none';
            if (state.inSearchMode) {
                alert("請在正常的資料夾瀏覽模式下使用此功能，而不是在搜索結果頁面。");
                return;
            }
            if (confirm(`您確定要掃描當前目錄：\n"${state.currentPath}"\n\n並將找到的新封面生成到對應的 COVER 資料夾中嗎？`)) {
                const options = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: state.mode, path: state.currentPath }),
                    clearContentOnLoad: false
                };
                const result = await fetchData('/api/generate_covers', options);
                if(result && result.status === 'started'){
                    alert("封面生成任務已在後台開始。\n完成後，請檢查封面目錄下的 'temp_generated_covers' 文件夾。");
                } else {
                    alert("啟動封面生成任務失敗。詳情請查看伺服器控制台日誌。");
                }
            }
        });

        subtitleSelector.addEventListener('change', (event) => {
            const newSubtitlePath = event.target.value;
            if (newSubtitlePath) {
                // 当用户选择新字幕时，调用 loadSubtitleTrack 来切换
                loadSubtitleTrack(newSubtitlePath);
            }
        });

        // --- Initial load ---
        async function initialize() {
            state.tagsData = await fetch('/api/tags').then(res => res.json()).catch(() => ({}));
            browse();
        }
        initialize();
        
    });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
</body>
</html>